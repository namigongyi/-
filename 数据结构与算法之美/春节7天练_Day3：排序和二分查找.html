<audio title="春节7天练_Day3：排序和二分查找" src="https://static001.geekbang.org/resource/audio/73/c3/73790422142ab8c78d6e8e5c1f1c3cc3.mp3" controls="controls"></audio> 
<p>你好，我是王争。初三好！</p><p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的30个代码实现，分7天发布出来，供你复习巩固所用。今天是第三篇。</p><p>和昨天一样，你可以花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p><p>前两天的内容，是关于数组和链表、排序和二分查找的。如果你错过了，点击文末的“<span class="orange">上一篇</span>”，即可进入测试。</p><hr><h2>关于排序和二分查找的几个必知必会的代码实现</h2><h3>排序</h3><ul>
<li>
<p>实现归并排序、快速排序、插入排序、冒泡排序、选择排序</p>
</li>
<li>
<p>编程实现O(n)时间复杂度内找到一组数据的第K大元素</p>
</li>
</ul><h3>二分查找</h3><ul>
<li>
<p>实现一个有序数组的二分查找算法</p>
</li>
<li>
<p>实现模糊二分查找算法（比如大于等于给定值的第一个元素）</p>
</li>
</ul><h2>对应的LeetCode练习题（@Smallfly 整理）</h2><ul>
<li>Sqrt(x) （x 的平方根）</li>
</ul><p>英文版：<a href="https://leetcode.com/problems/sqrtx/">https://leetcode.com/problems/sqrtx/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/sqrtx/">https://leetcode-cn.com/problems/sqrtx/</a></p><hr><p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p><p>祝你取得好成绩！明天见！</p><!-- [[[read_end]]] -->
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>李皮皮皮皮皮</span>
  </div>
  <div class="_2_QraFYR_0">各种排序算法真要说起来实际中使用的最多的也就是快排了。然而各种编程语言内置的标准库都包含排序算法的实现，基本没有自己动手实现的必要。然后作为经典的算法，自己实现一遍，分析分析时间空间复杂度对自己的算法设计大有裨益。需要注意的是为了高效，在实际的实现中，多种排序算法往往是组合使用的。例如c标准库中总体上是快排，但当数据量小于一定程度，会转而使用选择或插入排序。<br>求平方根使用牛顿法二分逼近😄</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-06 20:27:10</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/cf/f4/26b95f0b.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>TryTs</span>
  </div>
  <div class="_2_QraFYR_0">虽然现在有很多排序算法自己不会亲自写，但是作为算法的基础，分治，归并，冒泡等排序算法在时间复杂度，空间复杂度以及原地排序这些算法知识上的理解非常有帮助。递归分治这些算法思想在简单的算法中也能体现出来，其实更多的是思维方式的训练。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">编辑回复: 感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您99元专栏通用阅码，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-07 23:05:44</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>虎虎❤️</span>
  </div>
  <div class="_2_QraFYR_0">基本排序算法的关注点分为：<br>1. 时间复杂度。如n的平方（冒泡，选择，插入）；插入排序的优化希尔排序，则把复杂度降低到n的3&#47;2次方；n乘以logn(快排，归并排序，堆排序）。<br>2. 是否为原地排序。如，归并排序需要额外的辅助空间。<br>3. 算法的稳定性。稳定排序（by nature）如冒泡，插入，归并。如果把次序考虑在内，可以把其他的排序（如快排，堆排序）也实现为稳定排序。<br>4. 算法的实现。同为时间复杂度同为n平方的算法中，插入排序的效率更高。但是如果算法实现的不好，可能会降低算法的效率，甚至让稳定的算法变得不稳定。又如，快速排序有不同的实现方式，如三路快排可以更好的应对待排序数组中有大量重复元素的情况。堆排序可以通过自上而下的递归方式实现，也可以通过自下而上的方式实现。<br>5. 不同算法的特点，如对于近乎有序的数组进行排序，首选插入排序，时间复杂度近乎是n，而快速排序则退化为n平方。<br><br>二分查找，需要注意 (l+r)&#47;2可能存在越界问题。<br><br>leetcode题，用二分查找找到x*x &gt; n 且(x-1)的平方小于n的数，则n-1就是结果。或者 x的平方小于n且x+1的平方大于n,则返回x。</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-07 12:50:55</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>hopeful</span>
  </div>
  <div class="_2_QraFYR_0">#O(n)时间复杂度时间复杂度内找到一组数据的第 n大元素<br>import random<br>import time<br><br>def Array(n):<br>    a = []<br>    for i in range(n):<br>        a.append(random.randint(0 , n))<br>    return a<br>def QuickSort(n):<br>    array = Array(100)<br>    if n &gt; len(array) or n &lt; 1:<br>        print(&quot;超出范围，找不到&quot;)<br>        return<br>    n = n-1<br>    a = qsort(0 , len(array)-1 , array , n)<br>    print(sorted(array))<br>    print(&quot;-----------------------------&quot;)<br>    print(a)<br><br>def qsort(start , end , array , n):<br>    if start == end:<br>        res = array[start]<br>    if start &lt; end:<br>        key = partation(array , start , end)<br>        print(start , key , end)<br>        if key &gt; n :<br>            res = qsort(start , key-1 , array , n)<br>        elif key &lt; n:<br>            res = qsort(key+1 , end , array , n)<br>        else:<br>            res = array[key]<br>    return res<br><br>def swap(array , start , end):<br>    temp = array[start]<br>    array[start] = array[end]<br>    array[end] = temp<br><br>def partation(array , start , end):<br>    temp = array[start]<br>    while start &lt; end :<br>        while start&lt;end and array[end]&lt;=temp:<br>            end-=1<br>        swap(array , start , end)<br>        while start&lt;end and array[start]&gt;=temp:<br>            start+=1<br>        swap(array , start , end)<br>    return start</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-16 16:50:25</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>失火的夏天</span>
  </div>
  <div class="_2_QraFYR_0">牛顿法或者二分逼近都可以解决平方根问题，leetcode上有些大神的思路真的很厉害，经常醍醐灌顶</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-06 22:55:37</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/cf/f4/26b95f0b.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>TryTs</span>
  </div>
  <div class="_2_QraFYR_0">#include&lt;iostream&gt;<br>#include&lt;cmath&gt;<br>using namespace std;<br>double a = 1e-6;<br>double sqrt(double n){<br>	double low = 0.0;<br>	double high = n;<br>	<br>int i = 1000;<br><br>	while(i--){<br>		double mid = low + (high - low) &#47; 2.0; <br>		&#47;&#47;cout&lt;&lt;&quot;n:&quot;&lt;&lt;n&lt;&lt;endl;<br>		double square = mid * mid;<br>		&#47;&#47;cout&lt;&lt;&quot;sq:&quot;&lt;&lt;square&lt;&lt;endl;<br>		&#47;&#47;cout&lt;&lt;&quot;s:&quot;&lt;&lt;abs(square - n)&lt;&lt;endl;<br>		if(abs(mid * mid - n) &lt; a){<br>			return mid;<br>		}<br>		else{<br><br>			if(square &gt; n){<br>				high = mid;<br>			} <br>			else{<br>			    low = mid; <br>			}<br>		}<br>	}<br>	return -2.0;<br>}<br>int main(){<br>	double t;<br>	while(true){<br>		cin&gt;&gt;t;<br>		cout&lt;&lt;sqrt(t)&lt;&lt;endl;<br>	}<br>}</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-14 11:34:27</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/13/2e/45/d4039dd3.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Monster</span>
  </div>
  <div class="_2_QraFYR_0">&#47;**<br> * O(n)时间复杂度内求无序数组中第K大元素<br> *&#47;<br>public class TopK {<br><br>    public int findTopK(int[] arr, int k) {<br>        return findTopK(arr, 0, arr.length - 1, k);<br>    }<br><br>    private int findTopK(int[] arr, int left, int right, int k) {<br>        if (arr.length &lt; k) {<br>            return -1;<br>        }<br>        int pivot = partition(arr, left, right);<br>        if (pivot + 1 &lt; k) {<br>            findTopK(arr, pivot + 1, right, k);<br>        } else if (pivot + 1 &gt; k) {<br>            findTopK(arr, left, pivot - 1, k);<br>        }<br>        return arr[pivot];<br>    }<br><br><br>    private int partition(int[] array, int left, int right) {<br>        int pivotValue = array[right];<br>        int i = left;<br><br>        &#47;&#47;小于分区点放在左边 大于分区点放在右边<br>        for (int j = left; j &lt; right; j++) {<br>            if (array[j] &lt; pivotValue) {<br>                int tmp = array[i];<br>                array[i] = array[j];<br>                array[j] = tmp;<br>                i++;<br>            }<br>        }<br>        &#47;&#47;与分区点交换<br>        int tmp = array[i];<br>        array[i] = array[right];<br>        array[right] = tmp;<br>        return i;<br>    }<br>}</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">编辑回复: 感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您10元无门槛优惠券，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-13 18:22:35</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/18/03/ef0efcc4.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>EidLeung</span>
  </div>
  <div class="_2_QraFYR_0">编程实现 O(n) 时间复杂度内找到一组数据的第 K 大元素。<br>这个的时间复杂路应该是n·logk吧？</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-12 19:05:50</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/2d/59/b515a473.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Abner</span>
  </div>
  <div class="_2_QraFYR_0">java实现冒泡排序<br>代码如下：<br>package sort;<br><br>public class BubbleSort {<br><br>    public int[] bubbleSort(int[] array) {<br>        for (int i = 0;i &lt; array.length - 1;i++) {<br>            for (int j = 0;j &lt; array.length - i - 1;j++) {<br>                if (array[j] &gt; array[j + 1]) {<br>                    int temp = array[j + 1];<br>                    array[j + 1] = array[j];<br>                    array[j] = temp;<br>                }<br>            }<br>        }<br>        return array;<br>    }<br><br>    public static void main(String[] args) {<br>        int[] array = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};<br>        BubbleSort bubbleSort = new BubbleSort();<br>        int[] result = bubbleSort.bubbleSort(array);<br>        for (int i = 0;i &lt; result.length;i++) {<br>            System.out.print(result[i] + &quot; &quot;);<br>        }<br>    }<br><br>}<br></div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-11 17:44:01</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>kai</span>
  </div>
  <div class="_2_QraFYR_0">实现模糊二分查找算法2:<br><br>public class BinarySearch {<br>    &#47;&#47; 3. 查找第一个大于等于给定值的元素<br>    public static int bsFistGE(int[] array, int target) {<br>        int lo = 0;<br>        int hi = array.length - 1;<br><br>        while (lo &lt;= hi) {<br>            int mid = lo + ((hi - lo) &gt;&gt; 1);<br><br>            if (array[mid] &gt;= target) {<br>                if (mid == 0 || array[mid-1] &lt; target) {<br>                    return mid;<br>                } else {<br>                    hi = mid - 1;<br>                }<br>            } else {<br>                lo = mid + 1;<br>            }<br>        }<br><br>        return -1;<br>    }<br><br>    &#47;&#47; 4. 查找最后一个小于等于给定值的元素<br>    public static int bsLastLE(int[] array, int target) {<br>        int lo = 0;<br>        int hi = array.length - 1;<br><br>        while (lo &lt;= hi) {<br>            int mid = lo + ((hi - lo) &gt;&gt; 1);<br><br>            if (array[mid] &lt;= target) {<br>                if (mid == hi || array[mid+1] &gt; target) {<br>                    return mid;<br>                } else {<br>                    lo = mid + 1;<br>                }<br>            } else {<br>                hi = mid - 1;<br>            }<br>        }<br><br>        return -1;<br>    }<br>}</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-11 10:32:10</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>kai</span>
  </div>
  <div class="_2_QraFYR_0">实现模糊二分查找算法1:<br><br>public class BinarySearch {<br>    <br>    &#47;&#47; 1. 查找第一个值等于给定值的元素<br>    public static int bsFirst(int[] array, int target) {<br>        int lo = 0;<br>        int hi = array.length - 1;<br><br>        while (lo &lt;= hi) {<br>            int mid = lo + ((hi - lo) &gt;&gt; 1);<br><br>            if (array[mid] &gt; target) {<br>                hi = mid - 1;<br>            } else if (array[mid] &lt; target) {<br>                lo = mid + 1;<br>            } else {<br>                if (mid == lo || array[mid-1] != array[mid]) {<br>                    return mid;<br>                } else {<br>                    hi = mid - 1;<br>                }<br>            }<br>        }<br><br>        return -1;<br>    }<br><br>    &#47;&#47; 2. 查找最后一个值等于给定值的元素<br>    public static int bsLast(int[] array, int target) {<br>        int lo = 0;<br>        int hi = array.length - 1;<br><br>        while (lo &lt;= hi) {<br>            int mid = lo + ((hi - lo) &gt;&gt; 1);<br><br>            if (array[mid] &gt; target) {<br>                hi = mid - 1;<br>            } else if (array[mid] &lt; target) {<br>                lo = mid + 1;<br>            } else {<br>                if (mid == hi || array[mid] != array[mid+1]) {<br>                    return mid;<br>                } else {<br>                    lo = mid + 1;<br>                }<br>            }<br>        }<br><br>        return -1;<br>    }<br>}</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-11 10:31:49</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>kai</span>
  </div>
  <div class="_2_QraFYR_0">实现一个有序数组的二分查找算法:<br><br>public class BinarySearch {<br>    &#47;&#47; 最简单的二分查找算法：针对有序无重复元素数组<br>    &#47;&#47; 迭代<br>    public static int binarySearch(int[] array, int target) {<br>        if (array == null) return -1;<br><br>        int lo = 0;<br>        int hi = array.length-1; &#47;&#47; 始终在[lo, hi]范围内查找target<br><br>        while (lo &lt;= hi) {<br>            int mid = lo + ((hi - lo) &gt;&gt; 1); &#47;&#47; 这里若是 (lo + hi) &#47; 2 有可能造成整型溢出<br><br>            if (array[mid] &gt;  target) {<br>                hi = mid - 1;<br>            } else if (array[mid] &lt; target) {<br>                lo = mid + 1;<br>            } else {<br>                return mid;<br>            }<br>        }<br><br>        return -1;<br>    }<br><br>    &#47;&#47; 递归<br>    public static int binarySearchRecur(int[] array, int target) {<br>        if (array == null) return -1;<br>        return bs(array, target, 0, array.length-1);<br>    }<br><br>    private static int bs(int[] array, int target, int lo, int hi) {<br>        if (lo &lt;= hi) {<br>            int mid = lo + ((hi - lo) &gt;&gt; 1);<br>            if (array[mid] &gt; target) {<br>                return bs(array, target, lo, mid-1);<br>            } else if (array[mid] &lt; target) {<br>                return bs(array, target, mid+1, hi);<br>            } else {<br>                return mid;<br>            }<br>        }<br><br>        return -1;<br>    }<br>}</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-11 10:29:16</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>纯洁的憎恶</span>
  </div>
  <div class="_2_QraFYR_0">这道题似乎可以等价于从1到x中找到一个数y，使得y*y小于等于x，且（y+1）*（y+1）大于x。那么可以从1到x逐个尝试，提高效率可以采用二分查找方法，时间复杂度为O（logx）。</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-09 17:00:15</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/13/00/6f/aacb013d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>黄丹</span>
  </div>
  <div class="_2_QraFYR_0">王争老师初三快乐！<br>这是今天两道题的解题思路和代码<br>1. O(n)时间内找到第K大的元素：<br>解题思路：利用快排中分区的思想，选择数组区间A[0...n-1]的左右一个元素A[n-1]作为pivot，对数组A[0...n-1]原地分区，这样数组就分成了三部分，A[0..p-1],A[p],A[p+1...n-1],如果p+1=k,那么A[p]就是要求解的元素，如果K&gt;p+1,则说明第K大的元素在A[p+1...n-1]这个区间，否则在A[0...p-1]这个区间，递归的查找第K大的元素<br>2. Sqrt(x) （x 的平方根）<br>解题思路：利用二分查找的思想，从1到x查找x的近似平方根<br>代码：<br>https:&#47;&#47;github.com&#47;yyxd&#47;leetcode&#47;blob&#47;master&#47;src&#47;leetcode&#47;sort&#47;Problem69_Sqrt.java</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-07 18:35:30</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/ec/9d/4d705f03.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>C_love</span>
  </div>
  <div class="_2_QraFYR_0">Use Binary Search<br><br>class Solution {<br>    public int mySqrt(int x) {<br>        if (x == 0 || x == 1) {<br>            return x;<br>        }<br>        <br>        int start = 0;<br>        int end = (x &gt;&gt; 1) + 1;<br>        <br>        while (start + 1 &lt; end) {<br>            final int mid = start + ((end - start) &gt;&gt; 1);<br>            final int quotient = x &#47; mid;<br>            if (quotient == mid) {<br>                return mid;<br>            } else if (quotient &lt; mid) {<br>                end = mid;<br>            } else {<br>                start = mid;<br>            }<br>        }<br>        <br>        return start;<br>    }<br>}</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">编辑回复: 感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您99元专栏通用阅码，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-07 13:00:33</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Geek_86533a</span>
  </div>
  <div class="_2_QraFYR_0">不断学习，不断练习到今天。发现自己的代码能力、思考问题的能力有了明显的进步。感谢！</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-08-14 10:22:40</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>懒猫</span>
  </div>
  <div class="_2_QraFYR_0">打卡</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-05-23 10:03:35</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>hopeful</span>
  </div>
  <div class="_2_QraFYR_0">#二分查找变种<br>import random<br>import time<br><br>def Array(n):<br>    a = []<br>    for i in range(n):<br>        a.append(random.randint(0 , n))<br>    return a<br>#查找第一个值等于给定值的元素<br>def find_1(n):<br>    array = Array(100)<br>    array = sorted(array)<br>    left = 0<br>    right = len(array)-1<br>    while left &lt;= right:<br>        mid = int((left+right)&#47;2)<br>        if array[mid] &gt; n:<br>            right = mid - 1<br>        elif array[mid] &lt; n:<br>            left = mid + 1<br>        else:<br>            if mid==0 or array[mid] != array[mid-1]:<br>                return mid<br>            else:<br>                right = mid - 1<br>    print(&quot;找不到&quot;)<br>    return -1<br><br>#查找最后一个值等于给定值的元素<br>def find_2(n):<br>    array = Array(100)<br>    array = sorted(array)<br>    left = 0<br>    right = len(array)-1<br>    while left &lt;= right:<br>        mid = int((left+right)&#47;2)<br>        if array[mid] &gt; n:<br>            right = mid - 1<br>        elif array[mid] &lt; n:<br>            left = mid + 1<br>        else:<br>            if mid==right or array[mid] != array[mid+1]:<br>                return mid<br>            else:<br>                left = mid + 1<br>    print(&quot;找不到&quot;)<br>    return -1<br><br>#查找第一个值大于等于给定值的元素<br>def find_3(n):<br>    array = Array(100)<br>    array = sorted(array)<br>    left = 0<br>    right = len(array)-1<br>    while left &lt;= right:<br>        mid = int((left+right)&#47;2)<br>        if array[mid] &gt;= n:<br>            if mid==0 or array[mid-1]&lt;n:<br>                return mid<br>            else:<br>                right = mid - 1<br>        else array[mid] &lt; n:<br>            left = mid + 1<br>    print(&quot;找不到&quot;)<br>    return -1<br><br>#查找最后一个值小于等于给定值的元素<br>def find_4(n):<br>    array = Array(100)<br>    array = sorted(array)<br>    left = 0<br>    right = len(array)-1<br>    while left &lt;= right:<br>        mid = int((left+right)&#47;2)<br>        if array[mid] &lt;= n:<br>            if mid==right or array[mid+1]&gt;n:<br>                return mid<br>            else:<br>                left = mid + 1<br>        else array[mid] &gt; n:<br>            right = mid - 1<br>    print(&quot;找不到&quot;)<br>    return -1</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-17 00:56:06</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>hopeful</span>
  </div>
  <div class="_2_QraFYR_0">#实现一个有序数组的二分查找算法<br>import random<br>import time<br><br>def Array(n):<br>    a = []<br>    for i in range(n):<br>        a.append(random.randint(0 , n))<br>    return a<br><br>def find(n):<br>    array = Array(100)<br>    array = sorted(array)<br>    left = 0<br>    right = len(array)-1<br>    while left &lt;= right:<br>        mid = int((left+right)&#47;2)<br>        if array[mid] &gt; n:<br>            right = mid - 1<br>        elif array[mid] &lt; n:<br>            left = mid + 1<br>        else:<br>            return mid<br>    print(&quot;找不到&quot;)<br>    return -1</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-16 15:58:43</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>拉欧</span>
  </div>
  <div class="_2_QraFYR_0">x 的平方根 go 语言实现 <br>func mySqrt(x int) int{<br><br>	if x==0{<br>		return 0<br>	}<br>	min:=1<br>	max:=x<br><br>	for {<br>		mid:=min+(max-min)&#47;2<br>		if mid*mid==x{<br>			return mid<br>		}else if mid*mid&lt;x{<br>			if (mid+1)*(mid+1)&gt;x{<br>				return mid<br>			}else{<br>				min=mid+1<br>			}<br>		}else{<br>			max=mid-1<br>		}<br><br>	}<br>}</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-15 17:18:59</div>
  </div>
</div>
</div>
</li>
</ul>