<audio title="12_树的深度优先搜索（下）：如何才能高效率地查字典？" src="https://static001.geekbang.org/resource/audio/62/db/620a9d90a1b8433b9698a3a3faaf2cdb.mp3" controls="controls"></audio> 
<p>你好，我是黄申。今天咱们继续聊前缀树。</p><p>上节结尾我给你留了道思考题：如何实现前缀树的构建和查询？如果你动手尝试之后，你会发现，这个案例的实现没有我们前面讲的那些排列组合这么直观。</p><p>这是因为，从数学的思想，到最终的编程实现，其实需要一个比较长的过程。我们首先需要把问题转化成数学中的模型，然后使用数据结构和算法来刻画数学模型，最终才能落实到编码。</p><p>而在前缀树中，我们需要同时涉及树的结构、树的动态构建和深度优先搜索，这个实现过程相对比较复杂。所以，这节我就给你仔细讲解一下，这个实现过程中需要注意的点。只要掌握这些点，你就能轻而易举实现深度优先搜索。</p><h2>如何使用数据结构表达树？</h2><p>首先，我想问你一个问题，什么样的数据结构可以表示树？</p><p>我们知道，计算机中最基本的数据结构是数组和链表。</p><p><strong>数组适合快速地随机访问</strong>。不过，数组并不适合稀疏的数列或者矩阵，而且数组中元素的插入和删除操作也比较低效。</p><p>相对于数组，链表的随机访问的效率更低，但是它的优势是，<strong>不必事先规定数据的数量</strong>，表示稀疏的数列或矩阵时，可以更有效地利用存储空间，同时也利于数据的动态插入和删除。</p><p>我们再来看树的特点。树的结点及其之间的边，和链表中的结点和链接在本质上是一样的，因此，我们可以模仿链表的结构，用编程语言中的指针或对象引用来构建树。</p><!-- [[[read_end]]] --><p>除此之外，我们其实还可以用二维数组。用数组的行或列元素表示树中的结点，而行和列共同确定了两个树结点之间是不是存在边。可是在树中，这种二维关系通常是非常稀疏的、非常动态的，所以用数组效率就比较低下。</p><p>基于上面这些考虑，我们可以设计一个TreeNode类，表示有向树的结点和边。这个类需要体现前缀树结点最重要的两个属性。</p><ul>
<li>
<p>这个结点所代表的字符，要用label变量表示。</p>
</li>
<li>
<p>这个结点有哪些子结点，要用sons哈希映射表示。之所以用哈希，是为了便于查找某个子结点（或者说对应的字符）是否存在。</p>
</li>
</ul><p>另外，我们还可以用变量prefix表示当前结点之前的前缀，用变量explanation表示某个单词的解释。和之前一样，为了代码的简洁，所有属性都用了public，避免读取和设置类属性的代码。</p><p>这里我写了一段TreeNode类的代码，来表示前缀树的结点和边，你可以看看。</p><pre><code>/**
* @Description: 前缀树的结点
* 
*/
 
 public class TreeNode {
  
  public char label;  // 结点的名称，在前缀树里是单个字母
  public HashMap&lt;Character, TreeNode&gt; sons = null; // 使用哈希映射存放子结点。哈希便于确认是否已经添加过某个字母对应的结点。
  public String prefix = null;   // 从树的根到当前结点这条通路上，全部字母所组成的前缀。例如通路b-&gt;o-&gt;y，对于字母o结点而言，前缀是b；对于字母y结点而言，前缀是bo
  public String explanation = null;  // 词条的解释
  
  // 初始化结点
  public TreeNode(char l, String pre, String exp) {
   label = l;
   prefix = pre; 
   explanation = exp;
   sons = new HashMap&lt;&gt;();
   
  }
  
 }
</code></pre><p>说到这里，你可能会好奇，为什么只有结点的定义，而没有边的定义呢？实际上，这里的有向边表达的是父子结点之间的关系，我把这种关系用sons变量来存储子结点。</p><p>需要注意的是，我们需要动态地构建这棵树。每当接收一个新单词时，代码都需要扫描这个单词的每个字母，并使用当前的前缀树进行匹配。如果匹配到某个结点，发现相应的字母结点并不存在，那么就建立一个新的树结点。这个过程不好理解，我也写了几行代码，你可以结合来看。其中，str表示还未处理的字符串，parent表示父结点。</p><pre><code>// 处理当前字符串的第一个字母
char c = str.toCharArray()[0];
TreeNode found = null;

// 如果字母结点已经存在于当前结点(父节点)的子节点之下，找出它。否则就新生成一个
if (parent.sons.containsKey(c)) {
	found = parent.sons.get(c);
} else {
	TreeNode son = new TreeNode(c, pre, &quot;&quot;);
	parent.sons.put(c, son);
	found = son;
}
</code></pre><h2>如何使用递归和栈实现深度优先搜索？</h2><p>构建好了数据结构，我们现在需要考虑，<strong>什么样的编程方式可以实现对树结点和边的操作？</strong></p><p>仔细观察前缀树构建和查询，你会发现这两个不断重复迭代的过程，都可以使用递归编程来实现。换句话说，<strong>深度优先搜索的过程和递归调用在逻辑上是一致的</strong>。</p><p>我们可以把函数的嵌套调用，看作访问下一个连通的结点；把函数的返回，看作没有更多新的结点需要访问，回溯到上一个结点。在之前的案例中，我已经讲过很多次递归编程的例子，这里我就不列举代码细节了。如果忘记的话，你可以回去前面章节复习一下。</p><p>在查询的过程中，至少有三种情况是无法在字典里找到被查的单词的。于是，我们需要在递归的代码中做相应的处理。</p><p><strong>第一种情况：被查单词所有字母都被处理完毕，但是我们仍然无法在字典里找到相应的词条。</strong></p><p>每次递归调用的函数开始，我们都需要判断待查询的单词，看看是否还有字母需要处理。如果没有更多的字母需要匹配了，那么再确认一下当前匹配到的结点本身是不是一个单词。如果是，就返回相应的单词解释，否则就返回查找失败。</p><p>对于结点是不是一个单词，你可以使用Node类中的explanation变量来进行标识和判断，如果不是一个存在的单词，这个变量应该是空串或者Null值。</p><p><strong>第二种情况：搜索到前缀树的叶子结点，但是被查单词仍有未处理的字母，就返回查找失败。</strong></p><p>我们可以通过结点对象的sons变量来判断这个结点是不是叶子结点。如果是叶子结点，这个变量应该是空的HashMap，或者Null值。</p><p><strong>第三种情况：搜索到中途，还没到达叶子结点，被查单词也有尚未处理的字母，但是当前被处理的字母已经无法和结点上的label匹配，返回查找失败。是不是叶子仍然通过结点对象的sons变量来判断。</strong></p><p>好了，现在你已经可以很方便地在字典里查找某个单词，看看它是否存在，或者看看它的解释是什么。我这里又有一个新的问题了：<strong>如果我想遍历整个字典中所有的单词，那该怎么办呢？</strong></p><p>仔细观察一下，你应该能发现，查找一个单词的过程，其实就是在有向树中，找一条从树的根到代表这个单词的结点之通路。那么如果要遍历所有的单词，就意味着我们要找出从根到所有代表单词的结点之通路。</p><p>所以，在每个结点上，我们不再是和某个待查询单词中的字符进行比较，而是要遍历该结点所有的子结点，这样才能找到所有可能的通路。我们还可以用递归来实现这一过程。</p><p>尽管函数递归调用非常直观，可是也有它自身的弱点。函数的每次嵌套，都可能产生新的变量来保存中间结果，这可能会消耗大量的内存。所以这里我们可以用一个更节省内存的数据结构，栈（Stack）。</p><p>栈的特点是先进后出（First In Last Out），也就是，最先进入栈的元素最后才会得到处理。我画了一张元素入栈和出栈的过程图，你可以看看。</p><p><img src="https://static001.geekbang.org/resource/image/53/c1/5391e9f266cb795cec532cc54928b8c1.jpg?wh=1142*575" alt=""></p><p>为什么栈可以进行深度优先搜索呢？你可以先回顾一下上一节，我解释深度优先搜索时候的例子。为了方便你回想，我把图放在这里了。</p><p><img src="https://static001.geekbang.org/resource/image/90/b7/900c981c816375268eefdf274cb149b7.jpg?wh=1142*675" alt=""></p><p>然后，我们用栈来实现一下这个过程。（以下按入栈顺序说，文字的表述顺序可能不太准确，建议对照下方的图片学习）</p><p>第1步，将初始结点110压入栈中。</p><p>第2步，弹出结点110，搜出下一级结点123、879、945和131。</p><p>第3步，将结点131、945、879和123依次压入栈中。</p><p>第4步，重复第2步和第3步弹出和压入的步骤，先处理结点123，将新发现结点587和162依次压入栈中。</p><p>第5步，处理结点162，由于162是叶子结点，所以没有发现新的点。第6步，重复第2和第3步，处理结点587，将新发现结点681压入栈中。</p><p>……</p><p>第n-1步，重复第2和第3步，处理结点131，将新发现结点906压入栈中。</p><p>第n步，重复第2和第3步，处理结点906，没有发现新的结点，也没有更多待处理的结点，整个过程结束。</p><p><img src="https://static001.geekbang.org/resource/image/89/45/893203ec268e095397966b58e1c71d45.jpg?wh=1142*836" alt=""></p><p>从上面的步骤来看，栈先进后出的特性，可以模拟函数的递归调用。实际上，计算机系统里的函数递归，在内部也是通过栈来实现的。如果我们不使用函数调用时自动生成的栈，而是手动使用栈的数据结构，就能始终保持数据的副本只有一个，大大节省内存的使用量。</p><p>用TreeNode类和栈实现深度优先搜索的代码我写出来了，你可以看看。</p><pre><code>// 使用栈来实现深度优先搜索
public void dfsByStack(TreeNode root) {

  Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); 
	  // 创建堆栈对象，其中每个元素都是TreeNode类型
  stack.push(root);		// 初始化的时候，压入根结点

  while (!stack.isEmpty()) {	// 只要栈里还有结点，就继续下去
	
	TreeNode node = stack.pop();	// 弹出栈顶的结点
	
	if (node.sons.size() == 0) {
		// 已经到达叶子结点了，输出
		System.out.println(node.prefix + node.label);
	} else {
		// 非叶子结点，遍历它的每个子结点
		Iterator&lt;Entry&lt;Character, TreeNode&gt;&gt; iter 
			= node.sons.entrySet().iterator();
		
		// 注意，这里使用了一个临时的栈stackTemp
		// 这样做是为了保持遍历的顺序，和递归遍历的顺序是一致的
		// 如果不要求一致，可以直接压入stack
		Stack&lt;TreeNode&gt; stackTemp = new Stack&lt;TreeNode&gt;();
		while (iter.hasNext()) {
			stackTemp.push(iter.next().getValue());
		}
		while (!stackTemp.isEmpty()) {
			stack.push(stackTemp.pop());
		}
	}
  }

}	
</code></pre><p>这里面有个细节需要注意一下。当我们把某个结点的子结点压入栈的时候，由于栈“先进后出”的特性，会导致子结点的访问顺序，和递归遍历时子结点的访问顺序相反。如果你希望两者保持一致，可以用一个临时的栈stackTemp把子结点入栈的顺序颠倒过来。</p><h2>小结</h2><p>这一节我们用递归来实现了深度优先搜索。说到这，你可能会想到，之前讨论的归并排序、排列组合等课题，也采用了递归来实现，那它们是不是也算深度优先搜索呢？</p><p>我把归并排序和排列的分解过程放在这里，它们是不是也可以用有向树来表示呢？</p><p>在归并排序的数据分解阶段，初始的数据集就是树的根结点，二分之前的数据集代表父节点，而二分之后的左半边的数据集和右半边的数据集都是父结点的子结点。分解过程一直持续到单个的数值，也就是最末端的叶子结点，很明显这个阶段可以用树来表示。如果使用递归编程来进行数据的切分，那么这种实现就是深度优先搜索的体现。</p><p><img src="https://static001.geekbang.org/resource/image/54/12/5410fb301ffce57355ad7ef074e8fd12.jpg?wh=1142*856" alt=""></p><p>在排列中，我们可以把空集认为是树的根结点，如果把每次选择的元素作为父结点，那么剩下可选择的元素，就构成了这个父结点的子结点。而每多选择一个元素，就会把树的高度加1。因此，我们也可以使用递归和深度优先搜索，列举所有可能的排列。</p><p><img src="https://static001.geekbang.org/resource/image/98/15/98df21876ad52195217709e298707515.jpg?wh=1142*792" alt=""></p><p>从这两个例子，我们可以看出有些数学思想都是相通的，例如递归、排列和深度优先搜索等等。</p><p>我来总结一下，其实深度优先搜索的核心思想，就是按照当前的通路，不断地向前进，当遇到走不通的时候就回退到上一个结点，通过另一个新的边进行尝试。如果这一个点所有的方向都走不通的时候，就继续回退。这样一次一次循环下去，直到到达目标结点。树中的每个结点，既可以表示某个子问题和它所对应的抽象状态，也可以表示某个数据结构中一部分具体的值。</p><p>所以，我们需要做的是，观察问题是否可以使用递归的方式来逐步简化，或者是否需要像前缀树这样遍历，如果是，就可以尝试使用深度优先搜索来帮助我们思考并解决问题。</p><p><img src="https://static001.geekbang.org/resource/image/ae/c7/aeef1d5f6be9b5d09618a189520055c7.jpg?wh=1242*1521" alt=""></p><h2>思考题</h2><p>这两节我讲的是树的深度优先搜索。如果是在一般的图中进行深度优先搜索，会有什么不同呢？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/4d/20/02a1d4ac.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Jsoulan</span>
  </div>
  <div class="_2_QraFYR_0">感觉后面栈描述的过程像广度优先遍历呢</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 栈是先进后出，还是深度优先。队列先进先出，适合广度优先</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-01-09 09:20:23</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>pyhhou</span>
  </div>
  <div class="_2_QraFYR_0">对于思考题：<br>     1. 图中结点之间的关系是 “邻居”， 树中结点之间的关系 “父子”，如果是无向图，“邻居” 之间是互通的，但是 “父子” 默认是单向关系，一般遍历从 “父” 到 “子”，子结点中一般不保留父结点的信息<br>     2. 图和树不一样的是，图会存在 “环” 的概念，就是回路，树中永远不可能有回路，否则就不是一棵树<br>可以说链表是特殊的树，树是特殊的图。<br>综上所述，对比树，在一般的图中做深度优先搜索的区别就是：我们需要记录我们之前访问过的结点，防止重复访问</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 分析得很到位</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-03-12 06:39:08</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Wing·三金</span>
  </div>
  <div class="_2_QraFYR_0">用 python 实现了 DFS 和字典树，比起 C++ 简直不要简单太多，感觉有点暴殄天物……<br><br>### 在 python 中定义一个结点类<br>class Node:<br>    def __init__(self, alpha, pre, exp):<br>        self.alpha = alpha<br>        self.prefix = pre<br>        self.explanation = exp<br>        self.sons = dict()<br>    <br>    def find(self, alpha):<br>        if self.sons.get(alpha) == None:<br>            return False<br>        else:<br>            return True<br>        <br>    def create(self, alpha, son):<br>        self.sons[alpha] = son<br>        self.sons = {key: self.sons[key] for key in sorted(set(self.sons))}<br>        return True<br>    <br>    def get(self, alpha):<br>        return self.sons[alpha]<br><br>class DictTree:<br>    def __init__(self, words, alpha=&#39;&#39;):<br>        self.root = Node(alpha, &#39;&#39;, &#39;&#39;)<br>        self.build(words)<br>        <br>    def build(self, words):<br>        for word in words:<br>            self.add(word)<br>    <br>    def add(self, word):<br>        cur_node = self.root<br>        for i in word:<br>            i = i.lower()<br>            pre = cur_node.prefix + cur_node.alpha<br>            <br>            if not cur_node.find(i):<br>                cur_node.create(i, Node(i, pre, &#39;&#39;))<br>                <br>            cur_node = cur_node.get(i)<br>            <br>        cur_node.explanation = &quot;This is a pyeudo explanation of &#39;%s&#39;&quot; % word<br><br>    def DFS_search(self, word):<br>        word = word.lower()<br>        cur_node = self.root<br>        i = 0<br>        while True:<br>            if i == len(word):<br>                if cur_node.explanation != &#39;&#39;:<br>                    return cur_node.explanation<br>                else:<br>                    return &quot;The word &#39;%s&#39; is not in this dictionary.&quot; % word<br>            <br>            if cur_node.find(word[i]):<br>                cur_node = cur_node.get(word[i])<br>                i += 1<br>                continue<br>            else:<br>                return &quot;The word &#39;%s&#39; is not in this dictionary.&quot; % word<br><br>DFS 的实现可以用 list 代替 stack，在“压入”时可以用 reversed 函数直接逆序。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 是的 Python简洁很多</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-03-19 17:43:26</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Ben</span>
  </div>
  <div class="_2_QraFYR_0">第 3 步，将结点 123、879、945 和 131 压入栈中。<br>准确来说应该是 131, 945, 879, 123. 123是最后压栈的, 所以是最先出栈, 然后先处理123的子节点</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 确实是，严格来说应该按照入栈的顺序来说</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-09-10 18:01:16</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>罗耀龙@坐忘</span>
  </div>
  <div class="_2_QraFYR_0">茶艺师学编程<br><br>今天老师讲完了树的深度优先搜索。它本身是图论的遍历算法之一，(另一个是广度优先搜索BFS)，俗话说，就是&quot;一条路走到黑&quot;。<br><br>在有向树上，深度优先搜索借助堆栈工具可以无脑遍历——树的结构主要是由上至下的&quot;父子关系&quot;，走到一个&quot;叶子&quot;了，倒回去，换个方向，再走。<br><br>而在一般的图上，这样的走法就显得没那么效率了——至少其中某些点会被重复走很多遍。因为在一般的图上，点与点的关系就不光是单向的&quot;父子关系&quot;，平级、来回方向的，都有。</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-04-04 17:06:23</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Paul Shan</span>
  </div>
  <div class="_2_QraFYR_0">这里深度优先遍历的顺序和前一篇文章中的不太一样，区别在于前一篇文章中的深度遍历,当发现一个新节点的时候入栈，然后马上处理这个新节点也就是栈顶，这篇文章中是把一个节点相连的所有节点入栈，然后再处理栈顶元素，请问老师，我的理解是否准确？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 是的，一个只要访问最深的某条路径，一个是需要遍历所有路径</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-08-23 05:46:08</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/df/0a/4084d5fa.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>半湖思絮</span>
  </div>
  <div class="_2_QraFYR_0">字典树查找Java<br>public class Lesson12_1 {<br><br>    &#47;**<br>     * @Description: 前缀树的结点<br>     *&#47;<br>    class TreeNode {<br><br>        public char label;<br>        public HashMap&lt;Character, TreeNode&gt; sons = null;<br>        public String prefix = null;<br>        public String explanation = null;<br><br>        &#47;&#47; 初始化结点<br>        public TreeNode(char l, String pre, String exp) {<br>            label = l;<br>            prefix = pre;<br>            explanation = exp;<br>            sons = new HashMap&lt;&gt;();<br>        }<br><br>        private TreeNode build(String str, String exp, String pre, TreeNode root) {<br>            if (&quot;&quot;.equals(str)) {<br>                this.explanation = exp;<br>                return root;<br>            }<br>            &#47;&#47; 处理当前字符串的第一个字母<br>            char c = str.toCharArray()[0];<br>            TreeNode found = null;<br><br>            &#47;&#47; 如果字母结点已经存在于当前父结点之下，找出它。否则就新生成一个<br>            if (this.sons.containsKey(c)) {<br>                found = this.sons.get(c);<br>            } else {<br>                TreeNode son = new TreeNode(c, pre, &quot;&quot;);<br>                this.sons.put(c, son);<br>                found = son;<br>            }<br><br>            return found.build(str.substring(1), exp, pre + str.substring(0, 1), root);<br>        }<br><br>        public TreeNode build(String str, String exp) {<br>            return this.build(str, exp, &quot;&quot;, this);<br>        }<br><br>        public String search(String str) {<br>            if (&quot;&quot;.equals(str)) {<br>                return null;<br>            }<br><br>            TreeNode found = this;<br>            char[] chars = str.toCharArray();<br>            for (char c : chars) {<br>                if (!found.sons.containsKey(c)) {<br>                    return null;<br>                } else {<br>                    found = found.sons.get(c);<br>                }<br>            }<br><br>            return found.explanation;<br>        }<br>    }<br><br>    @Test<br>    public void test() {<br>        TreeNode treeNode = new TreeNode((char) 0, &quot;&quot;, &quot;&quot;);<br>        treeNode.build(&quot;hello&quot;, &quot;你好&quot;).build(&quot;helloworld&quot;, &quot;你好世界&quot;);<br>        System.out.println(treeNode.search(&quot;hello&quot;));<br>    }<br>}</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-12-12 10:06:48</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>张洋</span>
  </div>
  <div class="_2_QraFYR_0">老师遍历出所有的单词 是不是用explanation判断更合适，因为一个通路是可以有多个单词的。<br>public static void dfsByStack(){<br>        Stack&lt;TreeNode&gt;  stack = new Stack&lt;&gt;();<br>        stack.push(headNode);<br>        while(stack.size()&gt;0){<br>            TreeNode node = stack.pop();<br>            if(!StringUtils.isEmpty(node.explanation)){<br>                System.out.println(node.explanation);<br>            }<br>            Map&lt;Character, TreeNode&gt; sons = node.sons;<br>            sons.forEach((sonKey,sonValue)-&gt;{<br>                stack.push(sonValue);<br>            });<br>        }<br>    }</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 这也是可以的，适用于字典的应用场景👍</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-10-22 22:03:21</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>qinggeouye</span>
  </div>
  <div class="_2_QraFYR_0"># python 简单实现<br>class TreeNode(object):<br>    &quot;&quot;&quot;节点&quot;&quot;&quot;<br>    def __init__(self, label=None, prefix=None, explanation=None, is_word=False):<br>        &quot;&quot;&quot;:param label: 节点的名称 在前缀树里是单个字母<br>        :param prefix: 根节点到当前节点的字母组成的前缀<br>        :param explanation: 单词解释<br>        :param is_word: False不是一个单词&quot;&quot;&quot;<br>        self.explanation = explanation<br>        self.prefix = prefix<br>        self.label = label<br>        self.is_word = is_word<br>        self.sons = dict()  # 存放子节点<br><br>class Tree(object):<br>    def __init__(self):<br>        self._root = TreeNode()<br>    def add(self, word, explanation):<br>        &quot;&quot;&quot;向 Tree 中添加一个单词<br>        :param explanation: 单词解释<br>        :param word: 英文单词<br>        :return:&quot;&quot;&quot;<br>        cur = self._root  # 从根节点开始<br>        for c in word:  # 遍历单词中的字母<br>            if cur.sons.get(c, None) is None:<br>                if cur.prefix is None:<br>                    prefix = cur.label<br>                else:<br>                    prefix = cur.prefix + cur.label<br>                # print(prefix)<br>                cur.sons[c] = TreeNode(c, prefix)<br>            cur = cur.sons.get(c)<br>        # 单词字母遍历结束，添加单词解释<br>        cur.explanation = explanation<br>        cur.is_word = True<br>        # print(cur.explanation)<br><br>    @property<br>    def root(self):<br>        return self._root<br><br>def dfs_by_stack(root):<br>    &quot;&quot;&quot;使用栈来实现深度优先搜索 :param root: 根节点&quot;&quot;&quot;<br>    stack = list()  #元素TreeNode<br>    stack.append(root)  #压入根节点<br>    while len(stack) &gt; 0:  #只要栈有节点 继续<br>        node = stack.pop()  #弹出栈顶节点<br>        if node.is_word:<br>            print(node.prefix + node.label, node.explanation)  # 是一个单词，则输出<br>            if len(node.sons) == 0:<br>                continue<br>        stack_temp = [node.sons.get(son) for son in node.sons] <br>        while len(stack_temp) &gt; 0:<br>            stack.append(stack_temp.pop())<br>if __name__ == &quot;__main__&quot;:<br>    testTree = Tree()<br>    word_dict = {&#39;love&#39;: &#39;爱&#39;, &#39;like&#39;: &#39;喜欢&#39;, &#39;successful&#39;: &#39;成功的&#39;, &#39;success&#39;: &#39;成功&#39;}<br>    for _word, _explanation in word_dict.items(): <br>        testTree.add(_word, _explanation)<br>    dfs_by_stack(testTree.root) </div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-02-24 18:39:30</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/6a/8e/7b6ea886.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Joe</span>
  </div>
  <div class="_2_QraFYR_0">老师讲解的树有多个分支，这里用C++简单演示了下二叉树的DFS。<br>&#47;**<br> * Objective:Given a b-tree, do the depth-first-search(DFS) or traversal.<br> * Appraoch: stack, no recursion.<br> * Example:<br> *        1<br> *       &#47; \<br> *      2    3<br> *     &#47; \  &#47; \<br> *    4   5 6  7<br> * Output: <br> * preorder: 1 2 4 5 3 6 7<br> *&#47;<br><br>#include &lt;iostream&gt;<br>#include &lt;stack&gt;<br>using namespace std;<br><br>&#47;&#47; tree node<br>class TreeNode {<br>  public:<br>  int data;<br>  TreeNode* left = NULL;<br>  TreeNode* right = NULL;<br><br>  public:<br>  TreeNode(int data)<br>      : data(data) { <br>  } <br>};<br>&#47;&#47; depth-first-search<br>class DFS {<br>  public:<br>  void printDFS(TreeNode* root) { <br>    stack&lt;TreeNode*&gt; s;<br>    s.push(root);<br>    &#47;&#47; begins!<br>    while (!s.empty()) {<br>      TreeNode* temp = s.top();<br>      s.pop();<br>      &#47;&#47; push right first<br>      if (temp-&gt;right != NULL) {<br>        s.push(temp-&gt;right);<br>      }<br>      if (temp-&gt;left != NULL) {<br>        s.push(temp-&gt;left);<br>      }<br>      &#47;&#47; print data<br>      cout &lt;&lt; temp-&gt;data &lt;&lt; &quot; &quot;;<br>    }<br>  }<br>};<br>&#47;&#47; test!<br>int main(void) {<br>  &#47;&#47; build tree.<br>  TreeNode* root = new TreeNode(1);<br>  root-&gt;left = new TreeNode(2);<br>  root-&gt;right = new TreeNode(3);<br>  root-&gt;left-&gt;left = new TreeNode(4);<br>  root-&gt;left-&gt;right = new TreeNode(5);<br>  root-&gt;right-&gt;left = new TreeNode(6);<br>  root-&gt;right-&gt;right = new TreeNode(7);<br><br>  DFS test;<br>  cout &lt;&lt; &quot;Depth-First-Search: &quot; &lt;&lt; endl;<br>  test.printDFS(root);<br>}<br>输出：<br>Depth-First-Search: <br>1 2 4 5 3 6 7</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 很好的实现，代码简洁</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-01-17 22:51:12</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Being</span>
  </div>
  <div class="_2_QraFYR_0">广度优先一般用队列来做，FIFO，这样做到层级遍历；深度优先则用栈来做，FILO，这样做到按深度一条条的遍历下去。在实现上是这么区别的，我看上面有同学混淆了。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 总结的很好</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-01-09 19:25:20</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Leon Wong</span>
  </div>
  <div class="_2_QraFYR_0">利用栈这个数据结构作为辅助DFS遍历的工具确实很巧妙，节点信息都会存储到一个连续的存储空间，减少内存碎片的产生</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-11-29 10:51:43</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>013923</span>
  </div>
  <div class="_2_QraFYR_0">谢谢老师！</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-07-28 10:31:48</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/vFhAmp9beuRuZZL0GQibJqsUmXNz2LPTOU95fGJlG0TDmZOvVcmatV0wHltu3YpQ9PQCDFoeJibvFBl8zvmUDvtQ/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Geek_27ca2b</span>
  </div>
  <div class="_2_QraFYR_0">JS 实现的，就是散列表要自己实现一下。 地址：<br>https:&#47;&#47;github.com&#47;wss2020&#47;Frontend-04-Template&#47;tree&#47;master&#47;z.js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#47;%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%AF%BE&#47;4%20%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2&#47;1%20%E5%89%8D%E7%BC%80%E6%A0%91</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-01-12 16:53:36</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/13/01/9c/1a750bc7.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>l c</span>
  </div>
  <div class="_2_QraFYR_0">不是很理解为什么用显式栈实现dfs更省空间，我的理解中他们所用的空间是一样的。假使做全遍历，都是n(n为所有节点个数)。显式栈的优势不是只在于避免堆栈溢出吗？请老师解答一下。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 这个取决于每种语言和编程的具体实现是否有优化，如果没有优化，可能会导致每次嵌套调用的时候，都生成变量的副本</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-07-04 23:40:49</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/15/2f/bf/85b957fc.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>咕咕咕</span>
  </div>
  <div class="_2_QraFYR_0">那个用栈的应该属于bfs吧，虽说用的栈但还是一波一波往外扩的。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 栈一般用在dfs上，当然做适当修改也是可以做bfs，但是bfs队列就够了，所以不用了</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-05-08 20:20:04</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>喻茂</span>
  </div>
  <div class="_2_QraFYR_0">&#47;&#47; 定义往单词数中插入的单词<br>$wordsArr = [&#39;yes&#39;,&#39;no&#39;,&#39;yell&#39;,&#39;nyll&#39;];<br>$rootNode = new TreeNode(&#39;&#39;,&#39;&#39;,0,null); &#47;&#47; 定义一个空节点作为数的根节点<br>$tree = new Tree($rootNode);<br>foreach ($wordsArr as $wordsArrOne) {<br>	$curWordLen = strlen($wordsArrOne);<br>	$curPrefix = &quot;&quot;; &#47;&#47; 到目前为止的前缀<br>	$isCompleteWord=0; &#47;&#47; 是否为完整单词<br>	$curTreeSonNums = count($tree-&gt;root-&gt;childArr);<br>	<br>	$curtempNode = $tree-&gt;root;<br><br>	for ($i=0;$i&lt;=$curWordLen-1;$i++) {<br>		<br>		if ($i==$curWordLen-1) { &#47;&#47; 已经是完整单词<br>			$isCompleteWord = 1;<br>		}<br>		<br>		&#47;&#47; 如果当前的子层有这个字母无需插入节点<br>		$isexist = 0;<br>		foreach ($curtempNode-&gt;childArr as $curChildKey=&gt;$childOne) {<br>			if ($childOne-&gt;label == $wordsArrOne[$i]) {<br>				$isexist = 1; &#47;&#47; 字母已经存在<br>			}<br>		}<br>		if ($isexist == 0) { &#47;&#47; 没有需要插入节点<br>		<br>			$curLetterNode = new TreeNode($wordsArrOne[$i],$curPrefix,$isCompleteWord,null);<br>			$curtempNode-&gt;childArr[] = $curLetterNode;<br>			$curtempNode = $curtempNode-&gt;childArr[count($curtempNode-&gt;childArr)-1];<br>			<br>		} else {<br>			$curtempNode-&gt;childArr[$curChildKey]-&gt;isCompleteWord = $isCompleteWord;<br>			$curtempNode = $curtempNode-&gt;childArr[$curChildKey];<br>		}<br>		$curPrefix .= $wordsArrOne[$i]; &#47;&#47; 更新前缀<br>		<br>	}<br>}<br><br>&#47;&#47; 遍历树<br>$tree-&gt;preOrder($tree-&gt;root);<br><br>&#47;&#47; 查看某一单词是否在树中存在<br>echo &quot;&lt;br&gt;&quot;;<br>$tree-&gt;wordExists($tree-&gt;root,&#39;yes&#39;);<br>$tree-&gt;wordExists($tree-&gt;root,&#39;yel&#39;);<br>$tree-&gt;wordExists($tree-&gt;root,&#39;ok&#39;);<br>$tree-&gt;wordExists($tree-&gt;root,&#39;yess&#39;);<br><br>echo &quot;&lt;br&gt;&quot;;<br>$tree-&gt;dfsByStack($tree-&gt;root);</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-03-16 09:15:53</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>喻茂</span>
  </div>
  <div class="_2_QraFYR_0">&#47;&#47; 整个单词树<br>class Tree{<br>	public $root;<br>	public function __construct($root=null){<br>        $this-&gt;root = $root;<br>    }<br>	&#47;&#47; 前序遍历<br>	public function preOrder($node)<br>	{<br>		if (!is_null($node)) {<br>		  <br>		  echo $node-&gt;label.&quot;,&quot;;<br>		  foreach ($node-&gt;childArr as $childNodeOne) {<br>			  $this-&gt;preOrder($childNodeOne);<br>		  }<br>		}<br>	}<br>	&#47;&#47; 使用数组模拟栈打印所有单词<br>	public function dfsByStack($node) {<br>	<br>		$stackArr = [];<br>		array_push($stackArr,$node);<br>		while ($stackArr) {<br>			$curNode = array_pop($stackArr);<br>			if ($curNode-&gt;isCompleteWord==1) { &#47;&#47; 完整单词，直接打印<br>				echo $curNode-&gt;prefix.$curNode-&gt;label.&quot;&lt;br&gt;&quot;;<br>			}<br>			if (!empty($curNode-&gt;childArr)) {<br>				$curChildArr = array_reverse($curNode-&gt;childArr);<br>				foreach ($curChildArr as $curChildArrOne) {<br>					array_push($stackArr,$curChildArrOne);<br>				}<br>			}<br>		}<br>	}<br>	&#47;&#47; 查看某一单词是否在树中存在<br>	public function wordExists($node,$word) {<br>		$isExists = 0;<br>		$wordLen = strlen($word);<br>		<br>		&#47;&#47; 忽略根节点 从第一层节点查<br>		$nodeArr = $node-&gt;childArr;<br>		for ($i=0;$i&lt;$wordLen;$i++) {<br>			&#47;&#47; 定义当前层是否有字母可以匹配<br>			$curMatch = 0;<br>			if (empty($nodeArr)) { &#47;&#47; 单词长度还没到就到了树的子节点查找失败<br>				break;<br>			}<br>			foreach ($nodeArr as $nodeKey=&gt;$nodeArrOne) {<br>				if ($nodeArrOne-&gt;label == $word[$i]) { &#47;&#47; 匹配成功<br>					$curMatch = 1;<br>					break;<br>				}<br>			}<br>			if ($curMatch == 1) { &#47;&#47; 当前层查询成功<br>				$node = $nodeArr[$nodeKey];<br>				$nodeArr = $node-&gt;childArr;<br>			} else {<br>				break; &#47;&#47; 匹配失败<br>			}<br>		}<br>		if (($i == $wordLen) &amp;&amp; ($node-&gt;isCompleteWord == 1)) { &#47;&#47; 匹配到了最后一个字母这时要查看当前节点是不是完整单词<br>			$isExists = 1;<br>		}<br>		<br>		if ($isExists == 1) {<br>			echo &quot;查找成功&lt;br&gt;&quot;;<br>		} else {<br>			echo &quot;查找失败&lt;br&gt;&quot;;<br>		}<br>	}<br>	<br>}</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-03-16 09:15:40</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>喻茂</span>
  </div>
  <div class="_2_QraFYR_0">php示例<br>&#47;&#47; 每个节点<br>class TreeNode{<br>    public $label; &#47;&#47; 当前节点的名称，当前字母<br>	public $prefix=&quot;&quot;; &#47;&#47; 从树的根到当前结点这条通路上，全部字母所组成的前缀<br>	public $isCompleteWord=0; &#47;&#47; 是否为完整单词<br>    public $childArr=[]; &#47;&#47; 子节点集合<br>	<br>    public function __construct($label=&#39;&#39;,$prefix=&#39;&#39;,$isCompleteWord=0,$child=null){<br>        $this-&gt;label   = $label;<br>        $this-&gt;prefix = $prefix;<br>		if ($this-&gt;isCompleteWord==0) {<br>			$this-&gt;isCompleteWord = $isCompleteWord;<br>		}<br>		if ($child) {<br>			$this-&gt;childArr[] = $child;<br>		}<br>    }<br>}</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-03-16 09:15:26</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/4f/60/049a20e9.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>吴宇晨</span>
  </div>
  <div class="_2_QraFYR_0">图的dfs因为不一定全部联通要记一下访问过的节点，然后可能有环要判断一下吧</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 对，对于可能的环路要判断是否已经访问过</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-03-10 08:11:03</div>
  </div>
</div>
</div>
</li>
</ul>