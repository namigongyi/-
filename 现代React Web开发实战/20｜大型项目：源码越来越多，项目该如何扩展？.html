<audio title="20｜大型项目：源码越来越多，项目该如何扩展？" src="https://static001.geekbang.org/resource/audio/59/d1/590fbb9094a903c3d19bc33df8db3dd1.mp3" controls="controls"></audio> 
<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>上节课提到，为了应对大中型React项目的复杂应用逻辑，我们会分为<strong>局部</strong>和<strong>整体</strong>两个部分来学习。对于作为局部的组件逻辑，可以通过抽象来简化组件的设计和开发。我们学习了React中的自定义Hooks和组件组合这两种抽象方式，也学习了在这两种抽象基础上的代码复用，尤其是高阶组件的写法。</p><p>从局部到整体，复杂度会在代码量上直观地展现出来。在前端工程化和团队协作的基础上，大型React项目代码量上10万很常见。项目从最初的几行代码到如今的数十万代码，你可能会遇到如下问题：</p><ul>
<li>新功能的组件、Hooks、样式要不要分文件写，源文件都放到哪里？</li>
<li>Redux的action、reducer、store都写到哪里？</li>
<li>公共的代码放到哪里？</li>
<li>代码文件多到找不到怎么办？</li>
</ul><p>这节课我们会继续讨论React应用的整体逻辑，看看大中型React项目在代码增多后，整体扩展上会遇到的挑战，以及如何应对这些挑战。</p><h2>几种典型的React项目文件目录结构</h2><p>项目源码的文件目录结构并不等同于应用的整体逻辑，但却可以<strong>作为把握应用整体逻辑的一张“地图”</strong>。一个良好的文件目录结构是<strong>自解释</strong>的，可以帮助新接触项目的开发者快速熟悉代码逻辑。</p><!-- [[[read_end]]] --><p>React应用项目有以下五种典型的文件目录结构：</p><ul>
<li>单文件结构；</li>
<li>单目录结构；</li>
<li>按文件职能划分目录结构；</li>
<li>按组件划分目录结构；</li>
<li>按业务功能划分目录结构。</li>
</ul><p>接下来我们分别看一下。</p><h3>单文件结构</h3><p>是的，你没看错，单文件结构就是指，在单个React组件文件中开发所有业务逻辑。</p><p>你肯定亲眼见过这种结构，比如在<a href="https://time.geekbang.org/column/article/553817?">第3节课</a>里CRA创建的 <code>oh-my-kanban</code> 项目，不算样式的话，我们当时把所有代码都写在了 <code>src/app.js</code> 中。需要注意的是，这种结构只适合代码演示或微型的React项目。</p><h3>单目录结构</h3><p>比起单文件结构，这种结构拆分了组件文件，拆分的文件都放在同一个目录下。前面<a href="https://time.geekbang.org/column/article/571276">第12节课</a>末尾，<code>oh-my-kanban</code> 项目完成大重构第一步时的项目结构就是这样。目录树结构（有省略）如下：</p><pre><code class="language-plain">src
├── App.css
├── App.js
├── KanbanBoard.js
├── KanbanCard.js
├── KanbanColumn.js
├── KanbanNewCard.js
├── index.css
└── index.js
</code></pre><p>单目录结构比起单文件结构，能支撑更多组件以及相关逻辑，适合微型React项目。</p><h3>按文件职能划分目录结构</h3><p>顾名思义，在这种结构下，组件文件放一个目录，自定义Hooks文件放一个目录，context文件放一个目录，如果使用了Redux的话，actions、reducers、store各占一个目录（或者Redux Toolkit的slices和store目录）。</p><p><a href="https://time.geekbang.org/column/article/574161">在第13节课</a>，<code>oh-my-kanban</code> 项目完成大重构后，加入的第一个context就放到了独立的 <code>src/context</code> 目录。不只JS项目，在第18节课，我们尝试为TS项目加入的类型定义<code>src/types/KanbanCard.types.ts</code> ，也放到了专门的 <code>types</code> 目录下。目录树结构（有省略）如下：</p><pre><code class="language-plain">src
├── components
│&nbsp; &nbsp;├── App.css
│&nbsp; &nbsp;├── App.tsx
│&nbsp; &nbsp;├── KanbanBoard.tsx
│&nbsp; &nbsp;├── KanbanCard.tsx
│&nbsp; &nbsp;├── KanbanColumn.tsx
│&nbsp; &nbsp;└── KanbanNewCard.tsx
├── context
│&nbsp; &nbsp;└── AdminContext.ts
├── hooks
│&nbsp; &nbsp;└── useFetchCards.ts
├── types
│   └── KanbanCard.types.ts
├── index.css
└── index.tsx
</code></pre><p>按文件职能划分目录结构的优点在于，可以快速定位任何一种类型的源码，在源码之间导入导出也比较方便：</p><pre><code class="language-typescript">// src/components/App.tsx
import AdminContext from '../context/AdminContext';
</code></pre><p>当其中某个或者某几个目录中的文件数不断增多时，这种结构的缺点就暴露出来了：不容易定位到直接相关的源文件。比如 <code>hooks/useFetchCards.ts</code> 目前只有 <code>components/App.tsx</code> 在用，这从目录结构上是看不出来的，必须进到源码里去看，当 <code>components</code> 目录下的文件足够多时，要花些功夫才能确认这两个文件的关联关系。</p><h3>按组件划分目录结构</h3><p>这种目录结构为每个组件都划分了一个独立、平级的目录，只要跟这个组件强相关，都往这个目录里招呼。这种设计出于两个考虑：</p><ul>
<li>React的基本开发单元是组件；</li>
<li>同一组件的相关代码要尽量<strong>共置</strong>（<strong>Colocation</strong>，这里翻译成“托管”不太合适）。<br>
目录树结构的例子如下：</li>
</ul><pre><code class="language-plain">src
├── components
│   ├── App
│   │   ├── AdminContext.js
│   │   ├── App.css
│   │   ├── App.jsx
│   │   ├── App.test.jsx
│   │   ├── index.js
│   │   └── useFetchCards.js
│   ├── KanbanBoard
│   │   ├── KanbanBoard.css
│   │   ├── KanbanBoard.jsx
│   │   └── index.js
│   ├── KanbanCard
│   │   ├── KanbanCard.css
│   │   ├── KanbanCard.jsx
│   │   ├── KanbanNewCard.jsx
│   │   └── index.js
│   └── KanbanColumn
│       ├── KanbanColumn.css
│       ├── KanbanColumn.jsx
│       └── index.js
├── index.css
└── index.jsx
</code></pre><p>在每个目录中都有一个 <code>index.js</code> ，负责把当前目录的组件重新导出（Re-export）到目录外面去，这样其他组件在导入这个组件时，不需要关心目录里都有哪些实现，只关注作为入口的 <code>index.js</code> 就行。入口文件示意代码如下：</p><pre><code class="language-javascript">// src/components/KanbanCard/index.js
export { default as KanbanCard } from './KanbanCard.jsx';
export { default as KanbanNewCard } from './KanbanNewCard.jsx';
</code></pre><p>这种目录结构的优势在于，能为特定组件提供一定的封装性，在它专属的目录中能找到它强相关的所有代码。但它也有不足，面对一些跨组件复用的逻辑，可能会出现放到哪个组件目录都不太合适的窘境。</p><h3>按业务功能划分目录结构</h3><p>按业务功能划分目录结构，它与我们刚刚讲过的结构都不同，意味着目录划分的主要依据不再是具体框架中的某个具体技术概念（包括React的组件、Hooks、context，也包括Redux的action、reducer、store）。这使得按业务功能划分目录结构成为一个框架无关的方案，也就是说，其他框架的应用也可以利用这种目录结构。</p><p>目录树结构的例子如下：</p><pre><code class="language-plain">src
├── features
│&nbsp; &nbsp;├── admin
│&nbsp; &nbsp;│&nbsp; &nbsp;├── AdminContext.js
│&nbsp; &nbsp;│&nbsp; &nbsp;├── AdminDashboard.jsx
│&nbsp; &nbsp;│&nbsp; &nbsp;├── AdminSettings.jsx
│&nbsp; &nbsp;│&nbsp; &nbsp;└── index.js
│&nbsp; &nbsp;├── kanban
│&nbsp; &nbsp;│&nbsp; &nbsp;├── KanbanBoard.jsx
│&nbsp; &nbsp;│&nbsp; &nbsp;├── KanbanCard.jsx
│&nbsp; &nbsp;│&nbsp; &nbsp;├── KanbanColumn.jsx
│&nbsp; &nbsp;│&nbsp; &nbsp;├── KanbanNewCard.jsx
│&nbsp; &nbsp;│&nbsp; &nbsp;├── index.js
│&nbsp; &nbsp;│&nbsp; &nbsp;└── useFetchCards.js
│&nbsp; &nbsp;├── login
│&nbsp; &nbsp;│&nbsp; &nbsp;├── Login.css
│&nbsp; &nbsp;│&nbsp; &nbsp;├── Login.jsx
│&nbsp; &nbsp;│&nbsp; &nbsp;├── LoginForm.jsx
│&nbsp; &nbsp;│&nbsp; &nbsp;└── index.js
│&nbsp; &nbsp;└── user
│&nbsp; &nbsp; &nbsp; &nbsp;├── Password.jsx
│&nbsp; &nbsp; &nbsp; &nbsp;├── UserProfile.jsx
│&nbsp; &nbsp; &nbsp; &nbsp;├── UserSettings.jsx
│&nbsp; &nbsp; &nbsp; &nbsp;└── index.js
├── index.css
└── index.jsx
</code></pre><p>按业务功能划分目录结构可以说，它是这五种结构中最适合大中型React项目的。它既强调了相关源文件的共置，也在增加业务功能时具有良好的可扩展性。但它也具有与按组件划分目录结构类似的缺点，面对一些跨业务功能复用的逻辑，放在哪个业务目录下都不太合适。</p><h3>如何选取合适的文件目录结构？</h3><p>可以参考以下表格：</p><p><img src="https://static001.geekbang.org/resource/image/42/65/42ac6b3fe5ae14de728e6fda01a0d165.jpg?wh=1920x738" alt="图片"></p><h2>前端应用逻辑架构的功用</h2><p>当提到React应用的整体逻辑时，不知你是否还记得<a href="https://time.geekbang.org/column/article/553795">第2节课</a>这张应用逻辑架构图：</p><p><img src="https://static001.geekbang.org/resource/image/e9/40/e9b6711982510ef67fb690b8ddca9f40.jpg?wh=1920x1029" alt="图片"></p><p>我工作早些年间，流行的开发流程是瀑布式开发（Waterfall Model），当时的概要设计阶段和详细设计阶段，对设计文档尤其是架构图的要求非常严格（我画的这种五颜六色的图……基本会被驳回重画）。近些年软件行业追求效率，敏捷开发已经成为主流，但敏捷开发并没有拒绝文档化，也绝不应该被当作拒绝架构设计的借口。</p><p>无论是否精确、美观，这样的架构图<strong>有助于我们把握项目的整体走向</strong>，对于大中型React项目而言是一个值得的先期投入。</p><p>也许你会问：“架构图应该是由架构师来画吧？”</p><p>我会这样理解这个事情：架构设计是一项工作、一项技能，而架构师是一个职位，两者间没有直接的等号。以我个人的经历举例，我参加工作后画的第一张架构图，那是在工作第二年。后来那张图有幸被用到了几场技术评审中，在与技术Leaders交流的过程中起了大作用，反过来也让我学到了很多。当然，这纯粹是我的个人理解，具体情况因人而异。</p><p>你的下一个问题大概是：“好的，我知道架构图有用了，那具体来说，画架构图对文件目录结构有什么用？”</p><p>因为前面提到了：</p><blockquote>
<p>项目源码的文件目录结构并不等同于应用的整体逻辑，但却可以作为把握应用整体逻辑的一张“地图”。</p>
</blockquote><p>那么应用逻辑架构图就可以当作是<strong>“地图”的“地图”</strong>。</p><p>下面马上来了解一下，我们为大中型React项目推荐的文件目录结构，也看看跟上面的应用逻辑架构图有什么样的对应关系。</p><h2>大中型React项目推荐的文件目录结构</h2><p>当React项目规模属于中型或大型时，文件目录结构需要满足以下几个目标：</p><ul>
<li>便于横向扩展（即增加新功能点或视图）；</li>
<li>易于定位相关代码；</li>
<li>鼓励代码复用；</li>
<li>有利于团队协作。</li>
</ul><p>为了满足上面的目标，我推荐你以<strong>按业务功能划分为主，结合按组件、按文件职能的方式，划分目录结构</strong>。</p><p>参考的目录树结构（有省略）如下：</p><pre><code class="language-plain">src
├── components
│&nbsp; &nbsp;├── Button
│&nbsp; &nbsp;├── Dialog
│   ├── ErrorBoundary
│   ├── Form
│   │   ├── Form.css
│   │   ├── FormField.jsx
│   │   ├── Form.jsx
│   │   └── index.js
│&nbsp; &nbsp;├── ...
│   └── Tooltip
├── context
│&nbsp; &nbsp;├── ...
│&nbsp; &nbsp;└── UserContext.js
├── features
│   ├── admin
│   ├── dashboard
│   │   ├── activies
│   │   │   └── ActivityList.jsx
│   │   ├── charts
│   │   │   └── ...
│   │   ├── news
│   │   │   ├── news.png
│   │   │   ├── NewsDetail.jsx
│   │   │   └── NewsList.jsx
│   │   ├── Dashboard.css
│   │   ├── Dashboard.jsx
│   │   └── index.js
│   ├── kanban
│   │   ├── KanbanBoard.jsx
│   │   ├── index.js
│   │   └── useFetchCards.js
│   ├── home
│   ├── login
│   ├── ...
│   └── user
├── hooks
│&nbsp; &nbsp;├── ...
│&nbsp; &nbsp;└── useLocation.js
├── servies
│&nbsp; &nbsp;├── kanbanService.js
│&nbsp; &nbsp;├── ...
│   └── userService.js
├── index.css
└── index.jsx
</code></pre><p>对应上面的例子，首先建立 <code>features</code> 目录， <code>features</code> 下面的一级目录都对应一个相对完整的业务功能，目录中有实现这一功能的各类代码。</p><p>对于部分体量比较大的功能，可以根据需要在一级目录下加入二级目录，每个二级目录都对应一个相对独立的子功能（业务），目录内部是实现子功能的各类代码。必要时还可以加入三级、四级目录，但总体目录层级不应过深。所以我们说，在 <code>features</code> 目录，可以从横向、纵向两个方向扩展功能点。</p><p>在 <code>features</code> 目录之外，为公用的代码建立一系列职能型的目录，包括可重用组件的 <code>components</code> 目录、可重用Hooks的 <code>hooks</code> 目录； <code>context</code> 目录的主要目的不是重用，而是跨业务功能使用context； <code>services</code> 目录下，集中定义了整个应用会用到的远程服务，避免四散到各个业务模块中，甚至硬编码（Hardcode）。这些公用代码的目录层级不宜太深，以一到二级为主。</p><p>从代码的导入导出关系来看，在 <code>features</code> 目录下，原则上同级目录间的文件不应互相导入，二级、三级目录只应被直接上一级目录导入，不能反过来被下一级目录导入。<code>features</code> 目录的代码可以导入公用目录的代码，反过来公用目录的代码不能导入<code>features</code> 目录的代码。在任何时候都应该避免循环导入（Circular Import）。</p><p><img src="https://static001.geekbang.org/resource/image/7b/f4/7b07ff63751913yyaba2c770a89295f4.jpg?wh=1920x954" alt="图片"></p><p>来对应一下前面的逻辑架构图：</p><ul>
<li>图中的功能模块1、功能模块2再到功能模块m这一行，可以对应到features目录；</li>
<li>图中的服务器通信、前端路由、表单处理、错误处理这一行，可以分别对应到公用的services目录、hooks目录、components目录；</li>
<li>虽然在目录结构中没有体现，但用户认证、用户授权、前端监控等，也可以放到公用目录中实现。</li>
</ul><p>这节课到目前为止讲到的目录结构，都是以单个React项目为前提的。</p><p>根据实际项目需要，也有很多React项目使用了多项目或者monorepo的方式来开发和扩展，虽然编译构建、CI/CD更加复杂了，但更有利于多个团队的协作，提高整体开发效率。在这样的实践中，可以把追加功能点到同一个React项目（或monorepo的包）看作纵向扩展，把特定模块、可复用组件和逻辑抽取为独立React项目（或monorepo的包）看作横向扩展。</p><h3>模块导入路径过长怎么办？</h3><p>在大中型React项目中，有时会遇到这样的import语句：</p><pre><code class="language-typescript">// src/a/b/c/d/e/f/g/h/MyComponent.jsx
import Dialog from '../../../../../../../../components/Dialog';
</code></pre><p>这种情况，首先要确定MyComponent.jsx是否真有必要放到这么深的路径下。如果发现这在项目中是个普遍情况，那可以利用Node.js的<a href="https://nodejs.org/dist/latest-v16.x/docs/api/packages.html#subpath-imports">Subpath Imports</a>功能（<a href="https://github.com/vitejs/vite/pull/7770">Vite中尚未支持</a>），或是由前端构建工具提供的非标准的module别名（Alias）功能。</p><pre><code class="language-typescript">// Subpath Imports
import Dialog from '#components/Dialog';

// Alias
import Dialog from '@components/Dialog';
</code></pre><h2>小结</h2><p>今天这节课，我们了解了如何从整体层面应对大中型React应用逻辑的扩展，学习了5种典型的React项目文件目录结构，对比了它们各自的优劣势和适用项目规模。</p><p>然后学习了以按业务功能划分为主，结合按组件、按文件职能划分的目录结构的方式，来应对大中型React项目。同时也强调了前端应用逻辑架构对应用逻辑扩展的指导作用。</p><p>专栏的第三模块到目前为止，我们已经学习了大中型React项目的数据流、局部和整体逻辑的相关实践。</p><p>下节课我们会暂时从应用业务开发中跳出来，了解一下常见的React性能问题和优化方案。这些性能优化方案对各种规模的React应用基本都适用，目标都是保证优秀的用户体验。</p><h2>思考题</h2><ol>
<li>
<p>其实在业界，React项目中经常会有一个名叫 <code>common</code> 的目录。如果在这节课里讲到的，大中型React项目推荐的文件目录结构中，设置一个这样的 <code>common</code> 目录，你会往这个目录里放什么文件？不放什么文件？为什么？</p>
</li>
<li>
<p>在<a href="https://time.geekbang.org/column/article/561203?">第5节课</a>的思考题中：</p>
</li>
</ol><blockquote>
<p>除了浏览器，你在电脑上最常用的桌面应用是什么？是不是macOS的<strong>Finder</strong>或Windows的<strong>资源管理器</strong>？<br>
如果是的话就好办了。请你尝试把Finder或资源管理器当作要用React开发的Web应用，按自己的理解做一遍组件拆分。</p>
</blockquote><p>现在已知Finder或资源管理器是大型React项目，请你为这个项目设计一套文件目录结构，记得把自己在第5节课设计的组件文件都放进去。</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/30/61/98/0d6b499d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>船长</span>
  </div>
  <div class="_2_QraFYR_0">模拟的 Finder 目录结构，原本想采用按【业务功能】拆分的结构的，但做的过程中发现项目比较简单，采用这种模式反而会复杂，于是采用了按【文件职能】拆分的结构，结构如下：<br> YeahMyKanBan<br>│   │       └── FinderSimulate<br>│   │           ├── components<br>│   │           │   ├── Column.tsx<br>│   │           │   ├── CommonCard.tsx<br>│   │           │   └── SystemOperate.tsx<br>│   │           ├── context<br>│   │           │   └── myContext.ts<br>│   │           ├── index.tsx<br>│   │           └── pages<br>│   │               ├── HeaderMenu.tsx<br>│   │               ├── LeftMenu.tsx<br>│   │               └── MainContent.tsx<br>后面用了 vercel 进行了部署（codesanbox 部署 umi 项目有问题）<br>在线预览：🔗 https:&#47;&#47;react-learn2-orpin.vercel.app&#47;YeahMyKanBan&#47;FinderSimulate<br>源码地址：https:&#47;&#47;github.com&#47;TanGuangZhi&#47;ReactLearn&#47;tree&#47;main&#47;src&#47;pages&#47;YeahMyKanBan&#47;FinderSimulate</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，船长，我看过了你的demo和源码，非常棒！这是到目前为止专栏留言区里最完整的思考题答案了，感谢你的积极和认真。<br><br>确实像你说的，目前这个项目相对简单，还不需要使用更加复杂的文件目录结构。你这样的设计恰到好处，尤其是components和pages目录的分工明确，对后续扩展和维护会有很大帮助。<br><br>看到你的代码使用了TailwindCSS，是很棒的样式技术。<br><br>另外我对Finder首页代码有个小建议： https:&#47;&#47;github.com&#47;TanGuangZhi&#47;ReactLearn&#47;blob&#47;main&#47;src&#47;pages&#47;YeahMyKanBan&#47;FinderSimulate&#47;index.tsx#L18-L25 的 getColumnData 函数可以声明在 useUpdateEffect 回调函数的内部，这样做代码逻辑上并没有什么区别，但可以避免每次组件重新渲染时都创建一个新函数出来，算是一个小优化。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-18 18:03:23</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/30/61/98/0d6b499d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>船长</span>
  </div>
  <div class="_2_QraFYR_0">common 文件夹顾名思义是放公共文件、可复用逻辑的地方，比如网站的 Header，Footer，公共 util 等。<br>比如本次 Finder 项目的 左上角最大最小化按钮就应属于 common 目录的一部分，应为不止 Finder 用到了，macos 下所有的窗口都有这部分</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，船长，很棒的答案，“Finder 项目的 左上角最大最小化按钮”确实是个很典型的例子。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-18 18:22:26</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/30/61/98/0d6b499d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>船长</span>
  </div>
  <div class="_2_QraFYR_0">在写这个 demo 的时候想起之前困惑的一个问题，想请教下宋老师，即在 jsx 中 &lt;childComponent&#47;&gt; 与 childComponent() 这 2 种调用组件的方式有什么区别？<br>这是一个 demo，上面的输入框是用&lt;childComponent&#47;&gt;这种方式调用的，在输入时会有个输入框失焦的问题，下面用childComponent() 调用的就没这个问题。<br>demo 地址：https:&#47;&#47;codesandbox.io&#47;s&#47;fervent-ishizaka-mwusdq?file=&#47;App.tsx），</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，船长，你的第一种写法相当于在组件内动态定义了一个组件，而函数组件每次渲染都会执行整个函数，意味着每次都会新定义一个SearchForm组件，然后加入到渲染中。<br><br>React在重新渲染时会根据组件类型确定有哪个虚拟DOM（FiberNode）是可以复用的，然而每次渲染都定义新组件会导致React每次都新建虚拟DOM，最终销毁并新建真实DOM，导致失去焦点。<br><br>我从你的codesandbox fork了一份，把SearchForm组件定义在主组件外面就好了：  https:&#47;&#47;codesandbox.io&#47;s&#47;affectionate-water-jdrhfz?file=&#47;App.tsx</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-18 18:09:44</div>
  </div>
</div>
</div>
</li>
</ul>