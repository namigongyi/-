<audio title="05｜前端组件化：如何将完整应用拆分成React组件？" src="https://static001.geekbang.org/resource/audio/54/35/54023fb4ea2b5fc839278376da165235.mp3" controls="controls"></audio> 
<p>你好，我是宋一玮。</p><p>上节课我们从相当于React门面的JSX语法入手，了解了JSX是React核心API之一<code>React.createElement()</code> 的语法糖，是一种声明式的前端模版技术，然后深入学习了JSX的写法，也捎带提了一下JSX与React组件的关系。</p><p>那么这节课我们就来进一步讲讲React组件。</p><p>组件化开发已经成为前端开发的主流趋势，市面上大部分前端框架都包含组件概念，有些框架里叫Component，有些叫Widget。<strong>React更是把组件作为前端应用的核心</strong>。</p><p>不过无论是哪种框架，几乎每一位学习前端组件的开发者都会遇到下面这些问题：</p><ul>
<li>开发应用时是不是一定要拆分组件？一个应用我只用一个组件开发行不行？</li>
<li>如果一定要拆分组件，面对需求文档我该怎么下手？</li>
<li>组件拆分的粒度是应该大些还是小些？有没有可以参照的标准？</li>
</ul><p>其实<strong>组件拆分并无唯一标准</strong>。拆分时需要你理解业务和交互，设计组件层次结构（Hierarchy），以关注点分离（Separation Of Concern）原则检验每次拆分。另外也要避免一个误区：组件确实是代码复用的手段之一，但并不是每个组件都需要复用。</p><p>这节课我们就从实践入手，学习如何拆分React组件，同时也介绍一些最佳实践。相信这节课结束时，你对上面的问题已经有自己的答案了。</p><!-- [[[read_end]]] --><h2>为什么要组件化？</h2><p>在前端领域，<strong>组件是对视图以及与视图相关的逻辑、数据、交互等的封装</strong>。如果没有组件这层封装，这些代码将有可能四散在各个地方，低内聚，也不一定能低耦合，这种代码往往难写、难读、难维护、难扩展。</p><p>类似下面这样的HTML表单代码，常见于前几年所见即所得的网站制作工具：</p><pre><code class="language-xml">&lt;div id="_panel1"&gt;
&nbsp; &lt;form id="_form1"&gt;&lt;input name="__text1" value="" /&gt;&lt;/form&gt;
&lt;/div&gt;
&lt;div id="_panel2"&gt;
&nbsp; &lt;img id="_img1" src="" /&gt;
&lt;/div&gt;
&lt;div id="_panel3"&gt;
&nbsp; &lt;form id="_form2"&gt;&lt;input name="__check1" type="checkbox" value="checked" /&gt;&lt;/form&gt;
&lt;/div&gt;
&lt;div id="_panel4"&gt;
&nbsp; &lt;script type="text/javascript"&gt;
&nbsp; &nbsp; function _form3_submit(event) {
&nbsp; &nbsp; &nbsp; var data = {};
&nbsp; &nbsp; &nbsp; data.text1 = document.getElementById('_form1').elements['__text1'].value;
&nbsp; &nbsp; &nbsp; data.check1 = document.getElementById('_check1').elements['__check1'].value;
&nbsp; &nbsp; &nbsp; ajaxPost(_handler_url, data);
&nbsp; &nbsp; }
&nbsp; &lt;/script&gt;
&nbsp; &lt;form id="_form3" onsubmit="_form3_submit"&gt;
&nbsp; &nbsp; &lt;input name="__submit1" type="submit" /&gt;
&nbsp; &nbsp; &lt;input name="__reset1" type="reset" /&gt;
&nbsp; &lt;/form&gt;
&lt;/div&gt;
</code></pre><p>上面的代码貌似工整，但实则杂乱无章。工具生成代码时一定有它自己的模型，但很明显，这个模型不是面向开发者的。你若是接手了这样的代码，一定会欲哭无泪，还不如重写一遍。</p><p>也许在不远的将来，AI会代替我们开发前端应用，但现阶段，既然是由前端开发者编写代码，那么<strong>前端技术就有必要辅助开发者写出更好的代码</strong>。<strong>低耦合高内聚</strong>的封装已经被证明是更加有效的软件工程实践，那么组件化，就让前端开发走在了正确的道路上。</p><h2>为什么要有组件层次结构？</h2><p>比组件化更进一步的概念是<strong>组件层次结构</strong>（Hierarchy）。在面向对象编程里也有Hierarchy这个概念，一般是指父类子类之间的继承关系。</p><p>React并没有用类继承的方式扩展现有组件（类组件继承 <code>React.Component</code>类，但类组件之间没有继承关系），所以在React中提到Hierarchy，一般都是指组件与组件间的层次结构。</p><p>组件层次结构可以帮助我们在设计开发组件过程中，<strong>将前端应用需要承担的业务和技术复杂度分摊到多个组件中去，并把这些组件拼装在一起</strong>。</p><p>React组件层次结构从一个根部组件开始，一层层加入子组件，最终形成一棵组件树。假设我们有一个图书馆组件，那它对应的组件树可能是这样：</p><pre><code class="language-plain">图书馆
├── 分类阅览室
│ &nbsp; └── 书架
│ &nbsp; &nbsp; &nbsp; └── 图书
└── 借阅室
</code></pre><center><span class="reference">（你有多久没去过图书馆了？）</span></center><p>在这个例子中，图书馆组件是分类阅览室和借阅室的组合，而分类阅览室里面的陈列基本单元是书架，书架里才是图书（组件）。在开发图书馆组件时，不需要考虑图书组件；在开发书架组件时，也不需要考虑分类阅览室，更不需要考虑借阅室。这正符合我们常提到的关注点分离（Separation Of Concern）原则。</p><p>可以想象得到，这些组件最终能显示到浏览器里，肯定要在 <code>render()</code>方法中加入不少HTML元素。</p><h2>拆分React组件</h2><p>前面说的组件化和组件层次结构，基本也适用于其他前端框架。接下来具体到React，该如何拆分组件呢？</p><h3>用JSX协助拆分React组件</h3><p>如何拆分组件，首先影响的就是JSX的写法。反过来说，你<strong>可以用JSX来快速验证拆分出来的组件层次结构</strong>。</p><p>现在请你用手头的 <code>oh-my-kanban</code>项目（啥？你已经把第三节课写的代码删了？）做几个实验。第三节课的思考题是，请你安装FB官方的React Developer Tools扩展，并用扩展观察你的<code>oh-my-kanban</code> 项目。现在它不止是思考题了，而是这些实验的必要准备工作。</p><p>安装好了，先 <code>npm start</code> 在浏览器中打开 <a href="http://localhost:3000/">http://localhost:3000/</a>，打开开发者工具，切换到React的Component页签。如下图所示，你能看到一棵以 <code>App</code> 组件为根的组件树：</p><p><img src="https://static001.geekbang.org/resource/image/60/2f/603432f158760d60e4d4ff5578d6452f.png?wh=1312x712" alt="图片"></p><p>里面既没有 <code>kanban-board</code>，也没有  <code>kanban-column</code> ，直接就到 <code>KanbanCard</code> 了。</p><pre><code class="language-plain">App
├── KanbanNewCard
├── KanbanCard
├── KanbanCard
├── ...
└── KanbanCard
</code></pre><p>显然，React扩展并没有把 <code>&lt;main&gt;</code>、 <code>section</code> 当作组件，多个KanbanCard组件也没有分成“待处理”、“进行中”和“已完成”三个组，而是并列在了一起。不知你怎么样，我是犯了强迫症，我打算强迫React扩展认出这些组件。</p><p>目前的代码是这样的：</p><pre><code class="language-xml">&lt;main className="kanban-board"&gt;
  &lt;section className="kanban-column column-todo"&gt;
    &lt;h2&gt;待处理&lt;/h2&gt;
    &lt;ul&gt;
      { todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }
    &lt;/ul&gt;
  &lt;/section&gt;
  &lt;section className="kanban-column column-ongoing"&gt;
    &lt;h2&gt;进行中&lt;/h2&gt;
    &lt;ul&gt;
&nbsp;     { ongoingList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }
    &lt;/ul&gt;
  &lt;/section&gt;
  {/* ...省略 */}
&lt;/main&gt;
</code></pre><p>你会怎么做呢？答对了，就是把 <code>&lt;main&gt;</code>、 <code>section</code> 改写成React组件：</p><pre><code class="language-javascript">const KanbanBoard = ({ children }) =&gt; (
&nbsp; &lt;main className="kanban-board"&gt;{children}&lt;/main&gt;
);

const KanbanColumn = ({ children, className }) =&gt; {
&nbsp; const combinedClassName = `kanban-column ${className}`;
&nbsp; return (
&nbsp; &nbsp; &lt;section className={combinedClassName}&gt;
      {children}
    &lt;/section&gt;
&nbsp; );
};
</code></pre><p>这两个组件的props中都有一个<strong>叫</strong> <code>children</code> <strong>的属性</strong>，这个属性一般<strong>不需要显式地传值</strong>，只要在JSX中写这个组件的标签时，<strong>在闭合标签内部加入子元素即可</strong>，子元素会自动作为 <code>children</code> 传给标签对应的组件。</p><p>因此我们在下面代码中，会用新建的两个React组件替代原来的HTML元素：</p><p><img src="https://static001.geekbang.org/resource/image/eb/3a/eb20724dfe54960453440b7db52c5d3a.png?wh=1432x1096" alt=""></p><p>保存文件，页面刷新了。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/a5/be/a5567f698377d203d613b1a951a867be.png?wh=1312x712" alt="图片"></p><p>好，可以看到组件树包含了新写的两个组件，层次变深了，谢谢你满足了我的强迫症。</p><pre><code class="language-plain">App
└── KanbanBoard
  &nbsp; ├── KanbanColumn
  &nbsp; ├── KanbanColumn
  &nbsp; └── KanbanColumn
        ├── KanbanCard
        ├── ...
  &nbsp; &nbsp; &nbsp; └── KanbanCard
</code></pre><p>可以看出，无论是这两个组件之间，还是它们与之前就有的 <code>KanbanCard</code> 之间，并没有明显关联。也就是说，它们三个组件只需要各扫门前雪，不需要关心其他组件的实现。此外，虽然它们之间最终形成了树形层次结构，但这层联系是在最外层的 <code>App</code> 定义的。</p><p>这时我估计你也上头了，你提出 <code>&lt;h2&gt; 待处理 &lt;/h2&gt;</code> 、<code>&lt;ul&gt;&lt;/ul&gt;</code> 应该是 <code>KanbanColumn</code> 的实现细节，不应该由 <code>App</code> 来提供。我非常认同你的看法。</p><p>我们再进一步调整 <code>KanbanColumn</code> 组件：</p><p><img src="https://static001.geekbang.org/resource/image/1e/06/1e678a46fc57b0d1dd9yy9f1efbd8e06.png?wh=1390x626" alt=""></p><p>这样就可以把 <code>App</code> 的代码改成：</p><p><img src="https://static001.geekbang.org/resource/image/74/cd/74405d204d14f073de4ff8700cb00ecd.png?wh=1496x1104" alt=""></p><p>这下 <code>App</code> 的负担就更小了。然而敏锐的你发现，页面少了些东西——是的，“添加新卡片”的按钮被我省略掉了。那要怎样加回来呢？</p><p>可以用props传进去，具体来讲就是用 <code>title</code> 属性传进去。在为 <code>KanbanColumn</code> 加入 <code>title</code> 属性时，虽然在前面 <code>App</code> 的JSX代码中传了字符串值，但我们还没有约定它必须是什么类型。</p><p>按照目前的需要，我们希望传React元素进去：</p><pre><code class="language-javascript">&lt;KanbanColumn className="column-todo" title={
  待处理&lt;button onClick={handleAdd}
    disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;
}&gt;
&nbsp; { showAdd &amp;&amp; &lt;KanbanNewCard onSubmit={handleSubmit} /&gt; }
&nbsp; { todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }
&lt;/KanbanColumn&gt;
</code></pre><p>这么写貌似是我们想要的，但这次修改导致编译失败了。在命令行终端中或者是浏览器页面上都能看到报错信息：</p><pre><code class="language-javascript">Failed to compile.

SyntaxError: /Users/evisong/dev/projects/oh-my-kanban/src/App.js: Unexpected token, expected "}" (87:21)
&nbsp; 85 |&nbsp; &nbsp; &nbsp; &nbsp;&lt;KanbanBoard&gt;
&nbsp; 86 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;KanbanColumn className="column-todo" title={
&gt; 87 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;待处理&lt;button onClick={handleAdd}
&nbsp; &nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^
&nbsp; 88 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;
&nbsp; 89 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&gt;
&nbsp; 90 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ showAdd &amp;&amp; &lt;KanbanNewCard onSubmit={handleSubmit} /&gt; }
ERROR in ./src/App.js
Module build failed (from ./node_modules/babel-loader/lib/index.js):
SyntaxError: /Users/evisong/dev/projects/oh-my-kanban/src/App.js: Unexpected token, expected "}" (87:21)
</code></pre><p><img src="https://static001.geekbang.org/resource/image/38/a4/383d0a63f46171c713e75de958d098a4.png?wh=1312x712" alt="图片"></p><p>你可能会感到费解，一段文字加一个HTML元素，之前直接写在 <code>&lt;h2&gt;&lt;/h2&gt;</code> 里明明好好的，但抽取成props就不对了。从报错的位置可以看出是赋值给 <code>title</code> 属性的表达式有问题，但报错信息里提到的语法错误 <code>SyntaxError</code> 并没有告诉我们什么是正确写法，毕竟它不知道我们的本意是什么。</p><p>如果你还有印象，上节课提过一个小技巧，把这个有问题的表达式赋值给一个JS变量，看看会发生什么：</p><pre><code class="language-javascript">const todoTitle = (待处理&lt;button onClick={handleAdd}
    disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;);
</code></pre><p>虽然报错信息还是很模糊的语法错误，但你可以相信自己的判断，这并不是一段合法的JSX。我们来试着修改它，把“待处理”字符串包在一对HTML标签里：</p><pre><code class="language-javascript">const todoTitle = (&lt;span&gt;待处理&lt;/span&gt;&lt;button onClick={handleAdd}
    disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;);
</code></pre><p>这次编译有了更友好的错误信息：</p><pre><code class="language-javascript">SyntaxError: /Users/evisong/dev/projects/oh-my-kanban/src/App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment &lt;&gt;...&lt;/&gt;? (79:20)
&nbsp; 77 |&nbsp; &nbsp;};
&nbsp; 78 |&nbsp; &nbsp;const todoTitle = (
&gt; 79 |&nbsp; &nbsp; &nbsp;&lt;span&gt;待处理&lt;/span&gt;&lt;button onClick={handleAdd}
&nbsp; &nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^
&nbsp; 80 |&nbsp; &nbsp; &nbsp; &nbsp;disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;
&nbsp; 81 |&nbsp; &nbsp;);
&nbsp; 82 |&nbsp; &nbsp;return (
</code></pre><p>这段JSX最外层需要包一对 <code>Fragment</code> ，即 <code>&lt;&gt; &lt;/&gt;</code> ：</p><pre><code class="language-javascript">const todoTitle = (
&nbsp; &lt;&gt;
&nbsp; &nbsp; &lt;span&gt;待处理&lt;/span&gt;&lt;button onClick={handleAdd}
&nbsp; &nbsp; &nbsp; disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;
&nbsp; &lt;/&gt;
);
</code></pre><p>终于改对了！让我们把这段表达式放回 <code>title</code> 属性里。你在意的话，可以把额外加的 <code>&lt;span&gt;&lt;/span&gt;</code> 删掉，它并不是之前语法错误的原因。</p><pre><code class="language-javascript">&lt;KanbanColumn className="column-todo" title={
  &lt;&gt;
    待处理&lt;button onClick={handleAdd}
      disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;
  &lt;/&gt;
}&gt;
</code></pre><p>大功告成！恭喜你既完成了组件拆分，又保证了实现的功能与拆分 <code>KanbanBoard</code> 和 <code>KanbanColumn</code> 组件之前一致。</p><p>顺便提一下，React还流行过一波真·子组件（Sub-components）的设计模式，代表性的组件库有<a href="https://react.semantic-ui.com/#sub-components">Semantic UI React</a>、<a href="https://recharts.org/zh-CN/guide/getting-started">Recharts</a>。下面代码来自Semantic UI的官方例子：</p><pre><code class="language-xml">&lt;Message icon&gt;
  &lt;Icon name='circle notched' loading /&gt;
  &lt;Message.Content&gt;
    &lt;Message.Header&gt;
      Just one second
    &lt;/Message.Header&gt;
    We're fetching that content for you.
  &lt;/Message.Content&gt;
&lt;/Message&gt;
</code></pre><p>其中 <code>Message.Content</code> 组件就是 <code>Message</code> 组件的Sub-component。用这种方式改写<code>KanbanColumn</code> 组件，大概会是这样的JSX：</p><pre><code class="language-javascript">&lt;KanbanColumn className="column-todo"&gt;
  &lt;KanbanColumn.Title&gt;
    待处理&lt;button onClick={handleAdd}
      disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;
  &lt;/KanbanColumn.Title&gt;
  {/* ...省略 */}
&lt;/KanbanColumn&gt;
</code></pre><p>从JSX的角度看，这种模式下用 <code>KanbanColumn.Title</code> 子组件声明title，比前面的表达式赋值显得更加规整一些。如果你感兴趣的话，在后面的课程中我会讲解一下这种模式的具体实现。</p><h3>拆分组件的基本原则</h3><p>通过刚才的实验，我们相当于用 <code>oh-my-kanban</code> 项目做了一道填空题：</p><blockquote>
<p>现需用React技术开发一个看板应用项目，按照组件层次结构，可以将整个应用拆分成根组件 <code>App</code>、（1)组件、(2)组件和 <code>KanbanCard</code> 组件。</p>
<blockquote></blockquote>
<p>答案：（1）<code>KanbanBoard</code> ；（2）<code>KanbanColumn</code></p>
</blockquote><p>这个答案肯定是可以得分的，但这却不是唯一的答案。只要你认为合理，尽管可以拆分出 <code>KanbanTodoColumn</code> 、 <code>KanbanOngoingColumn</code> 、 <code>KanbanDoneColumn</code> 等，也可以把两个组件合并成 <code>KanbanBoardWithColumns</code> 。</p><p>有一点要专门提一下，在上面的实验中，我们先实现了DOM树，再返回来做组件拆分。而现实情况下，一般而言都是先做组件拆分，把具体实现留到拆分之后。类比一下，有点像是Java语言中先定义接口（Interface）再实现（Implement）接口，当然也可以先写一个实现再抽象一个接口出来。</p><p>就拆分方向而言，一般面对中小型应用，更倾向于从上到下拆分，先定义最大粒度的组件，然后逐渐缩小粒度；面对大型应用，则更倾向于从下往上拆分，先从较小粒度的组件开始。</p><p>无论从哪个方向拆分组件，都尽量遵守以下基本原则：</p><ol>
<li><strong>单一职责</strong>（Single Responsibility）<strong>原则</strong>。</li>
<li><strong>关注点分离</strong>（Separation of Concern）<strong>原则</strong>。</li>
<li><strong>一次且仅一次</strong>（DRY, Don’t Repeat Yourself）<strong>原则</strong>。</li>
<li><strong>简约</strong>（KISS，Keep It Simple &amp; Stupid）<strong>原则</strong>。<br>
你也许会怀疑我只是把最著名的几个编程原则罗列在这里，但请你放心，这些原则在后续的课程中都会一一露脸，届时会有实例来印证它们。</li>
</ol><h3>对拆分组件的建议</h3><p>最后我想分享一个对拆分组件的建议。</p><p><strong>决策疲劳</strong>（<a href="https://en.wikipedia.org/wiki/Decision_fatigue">Decision Fatigue</a>）是个心理学概念，大致意思就是说<strong>当你连续做决定时，你的决定的效率和效果都会逐渐下降，甚至会做出错误的决定。</strong></p><p>在开发React应用时，为了实现一个完整的设计稿，你需要将其拆分成若干组件。而组件可大可小，可复杂可简单，你往往在组件拆分阶段需要连续做出决策，在颗粒度、复杂度、可维护性、可测试性间达到平衡。</p><p>这就容易导致决策疲劳，可能造成的后果就是，越靠后拆分的组件越拿不准，越怀疑前面我是不是拆错了，搞得自己很累。</p><p>为了减轻或避免拆分组件时的决策疲劳，我的建议是：</p><ol>
<li>没必要追求一次性拆分彻底，在具体实现过程中依然可以继续拆分组件；</li>
<li>没必要追求绝对正确，在后续开发中可以根据需要，随时调整拆分过的组件；</li>
<li>在拆分组件时尽量专注，暂时不要分神去考虑其他方面（如后端），少做些决策；</li>
<li>在平时开发工作中有意积累组件拆分的经验，这会让你在后续的项目中游刃有余。</li>
</ol><p>另外预告一下，组件什么时候该用props、什么时候该用state、还有context，这也是React中容易导致决策疲劳的地方，后面课程里会讲到的单向数据流，可以帮你尽可能避免这种情况。</p><h2>对React子组件概念的澄清</h2><p>从第三节课开始，你可能已经对React的组件树形成了一个印象。如果你还有其他前端框架的开发经验，也许会很自然地把React组件树跟其他框架的组件树做类比，来帮助自己理解和学习。我个人也很推荐这种学习方式，类比老技术，在新技术学习初期是非常有帮助的。</p><p>但如果一直这样类比其他框架的组件树，你可能会对React独特的组件渲染机制有所误解，不利于后续课程的展开。所以在这节课末尾，正好是个合适的时机，澄清一下React的组件树跟其他框架有什么不一样。</p><p>严格来说，<strong>React没有组件树</strong>（Component Tree）<strong>，只有元素树</strong>（Element Tree），即从根元素开始，父元素子元素之间形成的树。上节课学到，React元素的子元素可以是可以是React组件渲染的元素、HTML元素，也可以是字符串，那么一定可以有下面的元素树：</p><pre><code class="language-plain">图书馆
├── main
│ &nbsp; └── div
│ &nbsp; &nbsp; &nbsp; └── 分类阅览室
└── footer
    └── "地址：XX路YY号"
</code></pre><p>其中图书馆、分类阅览室是React组件，<code>main</code> 、 <code>div</code> 是图书馆组件 <code>render()</code> 方法返回值的一部分，分类阅览室的渲染结果则作为前者 <code>div</code> 的子元素。</p><p>在React内部，尤其是引入新的 <a href="https://zh-hans.reactjs.org/docs/faq-internals.html#what-is-react-fiber">Fiber协调引擎</a>之后，已经逐步不再依赖以类（Class）为中心的实现。元素（Element）只是节点的POJO（Plain Old JavaScript Object）描述，非常轻量，元素本身并不负责实例化类组件或是调用render方法。在类组件的实例上，也没有<code>addChild()</code> ，<code>getParent()</code> 这样描述组件间父子关系的方法或属性。函数组件更是如此。</p><p>我们经常提到的组件树和父子组件，其实可以从<strong>组件声明</strong>和<strong>组件实例</strong>两个层面来理解。</p><p>从组件声明层面：根据静态代码，<strong>在一个组件返回的JSX中，加入另一个组件作为子元素，那么可以说前者是父组件，后者是子组件</strong>。父子组件形成的树即为组件树。</p><p>但这种定义方法有可能会有误判，比如我们把 <code>oh-my-kanban</code> 的App组件稍作修改（ <code>MyCustomTitle</code> 仅为示意，不用实现）：</p><pre><code class="language-javascript">const App = () =&gt; (
  &lt;&gt;
    &lt;MyCustomTitle&gt;&lt;h1&gt;我的看板&lt;h1&gt;&lt;/MyCustomTitle&gt;
    &lt;div&gt;
      &lt;KanbanBoard&gt;
        &lt;KanbanColumn title={&lt;MyCustomTitle&gt;&lt;h2&gt;待处理&lt;/h2&gt;&lt;/MyCustomTitle&gt;}&gt;
          &lt;KanbanCard /&gt;
          {/* ...省略 */}
        &lt;/KanbanColumn&gt;
      &lt;/KanbanBoard&gt;
    &lt;/div&gt;
  &lt;/&gt;
);
</code></pre><p>通过阅读静态代码，我们可以观察到组件间的关系如下：</p><ul>
<li>很容易看出 <code>MyCustomTitle</code> 和 <code>KanbanBoard</code> 都是 <code>App</code> 组件的子组件；</li>
<li>但要注意 <code>KanbanColumn</code> 不是 <code>App</code> 的子组件，而是 <code>KanbanBoard</code> 的子组件；</li>
<li><code>KanbanCard</code> 明显是 <code>KanbanColumn</code> 的子组件，但通过 <code>title</code> 属性传递的 <code>MyCustomTitle</code> 是不是 <code>KanbanColumn</code> 的子组件呢？因为我们提前知道了内部实现，所以会把它认作是子组件，但如果 <code>KanbanColumn</code> 对你而言是个黑箱的话，并不能100%肯定 <code>MyCustomTitle</code> 是前者的子组件。</li>
</ul><p>从组件实例层面：<strong>组件树是来自运行时的React元素树、从逻辑上排除掉HTML、Fragment等元素，仅保留对应React组件的元素节点而形成的精简树</strong>。在这棵组件树中，对应元素呈父子关系的一对组件可以称作父子组件。</p><p>仍然以上面包含 <code>MyCustomTitle</code> 的代码为例，在运行时会产生如下React元素树：</p><pre><code class="language-plain">App
└── Fragment
    ├── MyCustomTitle
    │   └── h1
  &nbsp; └── div
        └── KanbanBoard
            ├── KanbanColumn
            │   ├── MyCustomTitle
            │   │   └── h2
            │   ├── KanbanCard
            │   ├── KanbanCard
</code></pre><p>把这棵元素树中非组件的节点过滤掉：</p><p><img src="https://static001.geekbang.org/resource/image/87/21/87aba0b93aa85712bdbf3de594e2ed21.png?wh=1378x608" alt=""></p><p>会形成一棵逻辑上包含父子组件关系的React组件树，这正是你在React Developer Tools浏览器扩展中看到的：</p><pre><code class="language-plain">App
├── MyCustomTitle
└── KanbanBoard
    ├── KanbanColumn
    │   ├── MyCustomTitle
    │   ├── KanbanCard
    │   ├── KanbanCard
</code></pre><p>在后面的课程中，我们会讲到React的虚拟DOM和协调过程，那时你会对组件层级结构有更深入的理解。</p><h2>小结</h2><p>我们在这节课讲到了组件化是前端框架普遍采用的封装形式，将一个完整应用拆分成组件层次结构，会把业务和技术复杂度分摊到多个组件中去。</p><p>然后用oh-my-kanban项目的源码，实践了如何利用JSX协助拆分React组件。介绍了拆分组件的四个基本原则，也借此机会向你兜售了“决策疲劳”的理论。最后基于React的内部机制，形而上学地纠正了你对React子组件的理解。</p><p>下节课我们依然会从拆分组件工作入手，更深入地介绍React组件的渲染过程，也为之后要学习的组件生命周期、单项数据流等概念打基础。</p><p>最后附上本节课所涉及的源代码，供你学习与参考。对应的Pull Request是：<a href="https://gitee.com/evisong/geektime-column-oh-my-kanban/pulls/3">https://gitee.com/evisong/geektime-column-oh-my-kanban/pulls/3</a></p><p>此外，老师也打了一个v0.5.0版本标签：<a href="https://gitee.com/evisong/geektime-column-oh-my-kanban/releases/tag/v0.5.0">https://gitee.com/evisong/geektime-column-oh-my-kanban/releases/tag/v0.5.0</a></p><h2>思考题</h2><p>除了浏览器，你在电脑上最常用的桌面应用是什么？是不是macOS的<strong>Finder</strong>或Windows的<strong>资源管理器</strong>？</p><p>如果是的话就好办了。请你尝试把Finder或资源管理器当作要用React开发的Web应用，按自己的理解做一遍组件拆分。注意，拆分出来的组件不需要有完整的props、HTML、事件处理实现，只要能用JSX搭建出来即可。</p><p>希望通过这一过程，能帮助你巩固对React组件颗粒度的把握。我们下节课再见！</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>🐑</span>
  </div>
  <div class="_2_QraFYR_0">大家好，咱们课程的代码地址在这里哦👇<br><br>对应的Pull Request是： https:&#47;&#47;gitee.com&#47;evisong&#47;geektime-column-oh-my-kanban&#47;pulls&#47;3<br>打了一个v0.5.0版本标签： https:&#47;&#47;gitee.com&#47;evisong&#47;geektime-column-oh-my-kanban&#47;releases&#47;tag&#47;v0.5.0</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-01 18:58:50</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/96/87/bbdeb4ee.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>杨永安</span>
  </div>
  <div class="_2_QraFYR_0">哇，周四的凌晨更新</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 留言时间凌晨一点半，还请保重身体。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-01 01:33:15</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/96/87/bbdeb4ee.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>杨永安</span>
  </div>
  <div class="_2_QraFYR_0">好奇真子组件模式</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，杨永安，“真·子组件”学习心愿单+1，我记下来了：）</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-01 02:01:04</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/16/ea/c1/d9cb2299.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Lucas Lin</span>
  </div>
  <div class="_2_QraFYR_0">不理解为什么老师会说「就拆分方向而言，一般面对中小型应用，更倾向于从上到下拆分，先定义最大粒度的组件，然后逐渐缩小粒度；面对大型应用，则更倾向于从下往上拆分，先从较小粒度的组件开始。」，有例子或是不同拆分方向带来的优缺点吗？</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-12-09 23:45:01</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJnRUibp7LV1l6RA5E8BcLjwLIaOoQxyicM3iaZXcPrJPdMkGmvFHWxBV6sbib7FQK6YMaOdKo6oiaBRaA/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>InfoQ_3906e8b6c95f</span>
  </div>
  <div class="_2_QraFYR_0">React 的Component和Element是不是类似于Flutter的Widget和Element? Component&#47;Widget 只是轻量级的UI逻辑封装，也就是文章中说的POJO，真正参与渲染的其实是Element或更加底层的RenderObject(Flutter)</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-19 22:46:16</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/18/5d/74/2762a847.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>流乔</span>
  </div>
  <div class="_2_QraFYR_0">唉，现在写开源项目就特别容易决策疲劳</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，流乔，决策时需要考虑的因素越多，越容易决策疲劳，开源项目会被很多人用，代码也会被很多人读甚至改，决策因素不会比企业项目少。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-22 19:30:02</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/18/ca/f5/3f95bf91.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>tron</span>
  </div>
  <div class="_2_QraFYR_0">对 React 子组件概念的澄清这一小节<br>对于组件树和元素树的不同之处，有点不是太理解<br>不知道是不是可以理解为，组件树是代码运行前的结构，代码运行后，组件return出元素，就成了元素树呢</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，tron，你的理解基本是可行的。只要经过渲染，元素树就会存在。<br><br>在React技术社区，我观察到长久以来有很多人都没有努力去区分组件Component和元素Element，而有意无意地把两者混为一谈。在很多场景下这也无伤大雅。<br><br>但可以设想一种情况，你写了两个React函数组件A和B，A渲染的DOM结构比较复杂，在很深的DOM中使用了B。无论是自己开发还是与别人沟通，当你提到父组件和子组件，你一定更关心你自己开发的组件，即A和B，而不会刻意关注A和一堆&lt;div&gt;、&lt;span&gt;、&lt;li&gt;的父子关系，也不会关注某个&lt;div&gt;（或&lt;span&gt;、&lt;li&gt;）和B的父子关系。这时我们就需要从概念上把组件和元素区分开，组件这个概念更面向React应用开发者，而元素更面向框架底层，根据不同的场合选用合适的概念。<br><br>很遗憾React官方也没有完全贯彻这一点。在React的Fiber协调引擎中，在用统一的FiberNode模型描述JSX中的HTML元素时，将它的workTag标记起名为HostComponent。这有可能反过来影响开发者对React元素的理解。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-13 16:49:01</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>阿阳</span>
  </div>
  <div class="_2_QraFYR_0">周四，继续追</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-01 15:15:04</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/10/5b/25/d78cc1fe.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>都市夜归人</span>
  </div>
  <div class="_2_QraFYR_0">const KanbanBoard = ({ children }) =&gt; (  &lt;main className=&quot;kanban-board&quot;&gt;{children}&lt;&#47;main&gt;);<br>缺少 return</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，都市夜归人，感谢你捉虫，不过这次这个不是bug哈，ES6的箭头函数语法在函数体仅为单一表达式时，允许简写，类似这样：(params) =&gt; expression ，其中 expression 会成为返回值。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-01 09:47:57</div>
  </div>
</div>
</div>
</li>
</ul>