<audio title="直播加餐02｜Freewheel前端工程化的演进和最佳实践" src="https://static001.geekbang.org/resource/audio/92/b9/927a31761b4e7673cc24eb21beb06eb9.mp3" controls="controls"></audio> 
<blockquote>
<p>本文由编辑整理自宋一玮老师在极客时间直播中的演讲《前端工程化的最佳实践与演进》，详细视频请在b站搜索观看，或直接点击<a href="https://www.bilibili.com/video/BV1Va411G7Wc/?spm_id_from=333.337.search-card.all.click&vd_source=9a6de1dbe4831e63618355e534516ee4">链接</a>观看。以及，PPT获取地址<a href="https://pan.baidu.com/s/1Qz-rT_3kJJ-p9zd1RC0F8A?pwd=63U8">在这里</a>，提取码为：63U8。</p>
</blockquote><p>上节课我们通过软件开发生命周期，了解了前端开发为什么工程化，那么这节课，我就来相应地介绍一些我所亲身经历的前端工程化的最佳实践，希望能对你有所启发。</p><p>FreeWheel是我供职的公司，我们主要是一个视频广告平台，面向的是欧美客户，产品包括视频广告管理平台（这是一套非常复杂的UI）、Ad Serving、报表、预测。</p><p>从2014年开始，FreeWheel在前端架构层面就开始做一些与工程化相关的改进，所做的工作量很大，所以我会侧重介绍其中2-3个点，说明当时的痛点是什么，以及我们做工程化改进的初衷是什么。</p><h2>FreeWheel前端工程化的演进</h2><p>在2014年时我们就已经开始做一些前后端分离的工作，引入React，并且开始做资源组件库了。因为当时整个应用非常复杂，有300多万行的代码（非常恐怖的代码量），这在当时来说算是比较有远见的一个举措了。</p><p><img src="https://static001.geekbang.org/resource/image/2d/78/2ded43473122efce64679c2d304f0478.jpg?wh=2284x1225" alt=""></p><p>开始做自研组件库，一是市面上没有太多成型的组件库，另一个是我们这个行业，以及行业的这些用户也有一些特别的需求，所以我们当时用了一个构建工具，叫Browserify（如今已经退出历史舞台）。</p><!-- [[[read_end]]] --><p>2016年，我们有了SparkUI 1.x。这是一套React组件库，其中部分组件做了开源，现在主要基于React，还有Redux。</p><p>然后打包用的是Webpack，Webpack的版本从1到5，变化还是不小的。后来我们又引入了静态资源的这样一个服务器，也就是Nginx。那么问题来了，打包的结果最后如何能到Nginx上面去呢？</p><p>我们当时开发了一系列命令行工具，之后Nginx接cdn，这是肯定要做的，因为我们无论如何都要把Nginx做优化，也就是吞吐量的优化，毕竟它没办法保证我们在世界不同的地方，都能有一个比较能接受的速度去访问这些资源。</p><p>后来我们做了一件事情。因为我们说之前的Ruby-on-Rails，整个就是编译一次，然后构建一次，最后到上线一次。可能大家会没法想象，这整个过程要花两三个小时的时间，才能让代码到线上。</p><p>也就是说，很有可能你改了一行代码，需要花三个小时的时间才能在线上看到它，从前端开发来讲，这是一个比较难受的速度。所以我们在这一阶段的优化中，已经慢慢地把这个速度提上来了，也不需要完整地部署Ruby-on-Rails的内容了。</p><p>在这个时间节点，我们还推出了一个叫FDD（Frontend Delivery Decoupling）这样一个项目（名字是随便起的，不用太纠结）。这个项目实际上保证了我们每个业务模块都会有它自己的构建，并且它们是单独构建、单独上线，这样整个时间就会有很大的一个缩减。然后各个小团队之间也有一个灵活性，自主程度会有很大的提升。</p><p>2018年，我们还引入了Backend For Frontend，也就是BFF，主要是做动态的HTML模板，还有前端参数的一个下发。</p><p>到了20年，有一些新的前端项目已经开始上手TypeScript了。TS确实很强，对于巨型项目，它的把控力是很强的，让我们不太容易在中间迷失方向。</p><p>如果说你是这种弱类型的JS开发 ，很有可能开发的时候发现自己不知道数据的样子是什么，但是TS可以帮助你解决这些问题。</p><p>然后编译的工具也是Webpack，少数项目会用Vite。后来我们内部的组件库SparkUI还升级到了4.x。接着就是2021年，我们引入了微前端架构，这个在这节课最后会有比较详细的解释。</p><p>以上就是在开发过程中遇到各种痛点时，FreeWheel在前端工程化上所做的事情。</p><h2>FreeWheel前端工程化的一些最佳实践</h2><p>接下来我们就具体看看FreeWheel在前端工程化上会有哪些最佳实践。</p><h3>构建：Wepack耗时过长</h3><p><img src="https://static001.geekbang.org/resource/image/10/5f/10bf3ccf72f2a43773819cc41076ea5f.jpg?wh=2284x1365" alt=""></p><p>首先就是我们React项目，它的Webpack的耗时确实很长。如上图所示，可以看到耗时已经达到153秒，快三分钟了。</p><p>如果是在服务器上跑CI/CD的话，这个速度其实没什么问题，但如果在本地开发时也是这个速度，那必然是有点痛苦的。所以我们开展了一个优化的过程，把前端交付做解耦。</p><p>事实上，我们对于Wepack本身做过很多优化，比如Loader、Plug-in，等等，但发现这样的优化终归是有极限的。所以我们在想，能不能跳出这个盒子（Out of Box），看看是不是真的需要把所有代码一块打包呢？答案是不需要。</p><p>原因也比较简单。不同业务模块背后负责的团队，其实并不是完全在一块工作的状态。</p><p>比如说，虽然我的开发有公共的部分，但是也可以满足团队的需求。当把整个交付的东西解耦之后，其实单个业务模块的时间就省下来了。当然也没有省去很多时间，当时平均下来是在83秒左右，这个构建时间也不是特别地快。</p><p>没关系，我们继续优化。要知道，UI的内容是组件库，组件库要参与到构建里面，这中间可能会有一些转译的工作，或者说一些编译的工作。对于这些工作，我们是不是可以先提前做呢？也就是说，我们通过Wepack里面dll这种方式，先把公共模做一个构建，等到再基于公共模块去构建跨业务的模块的时候，时间就会减少。</p><p>当抽完公共模块，一般来说平均下来的构建时间为46秒，这样一来，其他模块用的时间也会相应减少。</p><p>公共模块有什么好处呢？对于每个业务模块来说，它的公共模块都是一样的时候，可以帮助我们进行跨业务模块复用，也就是浏览器缓存。</p><p>在浏览器上我们会给客户开一年的缓存。也就是说，客户只要在其中任何一个业务模块上访问过了，这个公共模块就会被缓存下来。如果再去跑其他模块的话，就不会再去读这块内容了。这是我们在工程化上的一个改进。</p><p>从这个改进的过程中可以看到，我们并不是简单地盯着Wepack里有多少玩法，去挤压它的性能，而是跳出来，看看是否还有改进的空间。这种跳出来的思维我觉得还是比较重要的。</p><p>不过后来我们拆分完了之后，觉得还是不够，因为公共的东西也变得越来越重了。那么还能不能再去挤压出一些效率呢？这一次，我们决定从NPM包上入手。</p><h3>发布NPM包</h3><p>在JS的整个生态里，最重要的一个中间产物就是NPM包，我们就可以把这些项目发布成NPM。发布NPM包也有几个阶段，一开始是靠人工，这还是很痛苦的。</p><p>不仅要确保有权限，然后发布包时还要去给包打Tag，提交到Git上。如果忘了打，到时候还得补上，最后经常出现补着补着补错了的情况。说句题外话，人会出错，这是一定的，因此也没必要去苛责这个人。换句话说，本来就应该是自动化做的事情，就不要让人一直去做，因为他终有一天会出错。</p><p>到后来我们改进为在持续集成里去发NPM包，也就是自动化的方式。Conventional commits，意思是说在你的git commit message里，我们可以用一些约定俗成的方式，比如说feat，然后再在后面加一些描述。如果说你有Breaking Change（破坏性更新），你就加一行Breaking Change。</p><p>后面还会有一些描述，当这个东西进去以后，比如说如果只有feat，会帮我们去做一个小版本的更新。假设之前是1.2.3，现在变成1.3.0。如果我有Breaking Change，我就告诉Commit说是有Breaking Change，最后就会变成2.0.0发布。</p><p>同时，CI也会在Jenkins里面去跑，每次也会探测和判断一下，检查一下我都有哪些Change，是不是需要发包，甚至如果完全没有Change ，就直接跳过。当然，在发包之前肯定要过Lint和Test。</p><p>如果我们现在的分支属于main分支，我发的就是正式版本，比如1.1.0。但如果我现在是一个next分支 ，就会发一个pre-release版本，比如1.2.0-alpha.0，类似这样的。</p><p>甚至，当我发完包以后 ，lerna会帮我们自动创建一个Git的tag，把这个tag，还有commit都提交上去。提交进去以后，我们还要根据当时的main分支去重新创建一个next分支出来，保证我下次再合并next分支时不会出现太大的冲突。这套机制在我们公司用得还是蛮舒服的，帮助我们解决了很多问题。</p><p>这样一来，无论是业务团队还是我们得兄弟团队，当有新版本发布的时候，只要去看新版本，装到自己的项目里就可以了，当然也可以选择不装。</p><p>总结来说，通过CI/CD的方式提高了我们工程实践上的效率，也是比较革命性的一个事情了。当然，我们还是借助了外面的工具，也发现无论是Webpack还是后来的NBA包，它们都是有极限的。</p><h3>构建：Vite</h3><p>当团队变多了，项目也需要越来越快的响应的时候，其实Wepack就没那么够用了，这时我们看到了Vite2.0这个工具，这确实是非常赞的一个版本。</p><p>Vite2.0 并不是纯粹的从零产生的一个工具，它的基础是开发服务器，实际上依赖了esbuild这样一个比较成熟的基于Go语言的工具。源文件无需打包，依赖项使用esbulid预构建，直接以原生ES Modules形式即可加载到浏览器中。</p><p>在生产构建上，是基于Rollup这个工具，针对生产环境的打包命令。说句题外话，Rollup其实在打NPM包的时候用得非常广泛，所以这是两种工作模式，后来共同组成了 Vite2.0。</p><p>Vite2.0其实利用了浏览器的特性，现在最新浏览器已经支持ES Modules了。</p><p>既然支持了，那么在这种开发模式下，我们也不太关心它是不是一定要有特别好的性能，因为我们可以让浏览器来去一些不需要Bundle的JS文件。</p><p>这个时候其实又省了一个步骤，也就是不需要Bundle了，可以说，Vite在整个设计层面就已经很快了。</p><p>我放一下这个片 ，其实也是从里面拿过来的一个片，左面是一个在线的Create React application架子，然后创建一个项目，右面是创建一个Vite React的项目。</p><p><img src="https://static001.geekbang.org/resource/image/4d/1a/4d7feae454511493b0b2a08ec7c4cc1a.jpg?wh=2284x1470" alt=""></p><p>其实我在说这句话的期间，右边已经创建完，并且可以用了，而左边这部分还在跑。从开发的角度来讲，Vite这种开发性能的提升是指数级的，可以为我们的项目带来很多提升。但同时里面也有坑 ，鉴于不是咱们这节课的重点，我就先略过。</p><h3>微前端</h3><p>在工程化的实践改进上，我们刚才大都是在构建这方面做优化、提高效率，现在让我们回到业务上，从各个团队的工作方式来看，是不是还有其他方式可以提高我们的灵活性，然后解放生产力呢？这个时候我们看到了微前端架构。</p><p>最大的改进就是微前端容器。前端开发者都知道，在公共的部分，比如说页头页面上，我们主要关心公共导航、错误处理、用户认证逻辑等。对此，我们没有必要在每个业务模块里都写一份，或者是都通过NPM包的方式包装一次。</p><p>那么我们可以通过微前端的方式做一个容器，相当于把公共的东西就固定在那里，不会再变。然后对于每个业务模块 ，我们可以把它独立打包部署成子应用，不限制React版本，不限制构建技术，而是根据路由按需加载子应用。</p><p>而且微前端有这样一个好处，它可以保证这些子应用样式是有一个隔离的。比如JS有一定的隔离，然后是子应用。可能一个子应用是用TypeScript加上React 17来写的，另一个子应用可能是JS再加上React v.18来写。</p><p>甚至可能有一些老的应用，干脆就不更新了，就是React 15加Webpack来写的，我们都做了这样的改进，让它们可以成为这种子应用。</p><p>这样得话，我们在整个Container里面就可以跑一些异构的子应用，从而解放生产力。</p><h2>互动时刻</h2><p>对于前端工程化，你有经历过一些实践吗？成功还是失败了呢？可以分享一下你的经验吗？</p><p>欢迎通过留言告诉我，我们一起交流进步，下节课将进入一个新的模块！</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJnRUibp7LV1l6RA5E8BcLjwLIaOoQxyicM3iaZXcPrJPdMkGmvFHWxBV6sbib7FQK6YMaOdKo6oiaBRaA/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>InfoQ_3906e8b6c95f</span>
  </div>
  <div class="_2_QraFYR_0">现在web工程的复杂度已经和App工程有得一拼了</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-23 09:03:37</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/15/21/8c/e7241683.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>墨白™</span>
  </div>
  <div class="_2_QraFYR_0">做过微前端+BFF，两者做完的感受就是，技术不是最难的，最难的是想清楚这些技术引入能不能为当前业务有一些增益部分。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，墨白™，你说得太对了。Web应用主要还是业务应用，Web技术最终要服务于业务。在公司环境下尤其如此，不仅要想清楚技术会带来的增益，还要评估成本和风险，能让利益相关方也买账，消除对方的疑虑。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-11-29 21:36:10</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/19/64/6f2b7b86.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>01</span>
  </div>
  <div class="_2_QraFYR_0">老师您觉得微前端具体解决什么问题呢？ 是应该奔着使用微前端为前提来开发应用， 还是从前期通过更好的约定或者工程来解决呢</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，01，我个人认为，多人或多个团队开发同一个产品软件，在共同约定或者工程方式的成本不高的情况下，引入微前端的好处并不明显。<br><br>在微前端架构下：<br>* 每个子应用（或称微应用）都可以作为一个黑箱，内部技术、数据、通信基本都与其他子应用相隔离，比如子应用A用JS + React 18 + Webpack开发，而B用TS + React 17 + Vite开发，甚至C用Vue开发；<br>* 各个子应用的（软件开发）生命周期也互不影响，如子应用A每周上线两次，而B每半天上线一次；<br>* 子应用之间的交互相对较少；<br>* 微前端的容器提供路由、鉴权等公用的基础能力。<br><br>以上几点都是技术相关的。在技术之外，我认为微前端带来的最大收益还是，对于工作在同一个软件产品上的多个开发团队，每个团队都具有了更高的自治权。<br><br>但这个收益是好是坏，还是跟企业的内部情况相关。更高自治权会鼓励团队跑得更快，减少来自其他团队的制约；但同时也在研发整体层面带来了不确定性，一些公共的模块、代码难以收敛，可能会导致研发资源浪费。<br><br>我所在的FreeWheel引入微前端架构的一大动机是，优化跨地区&#47;时区的多个开发团队的协作。比如北京和纽约两地的团队，在同一个项目内工作时沟通协作成本还是很高的，把各自负责的功能模块拆分成子应用后，双方都提升了开发效率。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-11-16 23:07:09</div>
  </div>
</div>
</div>
</li>
</ul>