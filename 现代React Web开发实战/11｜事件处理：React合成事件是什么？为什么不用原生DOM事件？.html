<audio title="11｜事件处理：React合成事件是什么？为什么不用原生DOM事件？" src="https://static001.geekbang.org/resource/audio/6e/44/6e962ab9b6a7853b786a6dc78c7acd44.mp3" controls="controls"></audio> 
<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>前面两节课我们学习了React Hooks，加上前面第8节课学到的组件生命周期方法，这些API都可以用来编写组件逻辑。不过到目前为止，我们讲到的组件逻辑以展示为主，与用户的交互是偏单向的，而在实际项目中，Web应用也包含很多<strong>双向交互</strong>。实现双向交互的一个重要途径，就是<strong>事件处理</strong>。</p><p>在浏览器中，事件处理不是一个新鲜的概念。标准的DOM API中，有完整的DOM事件体系。利用DOM事件，尤其是其捕获和冒泡机制，网页可以实现很多复杂交互。</p><p>React里内建了一套名为<strong>合成事件</strong>（SyntheticEvent）的事件系统，和DOM事件有所区别。不过第一次接触到合成事件概念的开发者，常会有以下疑问：</p><ul>
<li>什么是React合成事件？</li>
<li>为什么要用合成事件而不直接用原生DOM事件？</li>
<li>合成事件有哪些使用场景？</li>
<li>有哪些场景下需要使用原生DOM事件？</li>
</ul><p>经过这节课的学习，你将了解到<strong>合成事件的底层仍然是DOM事件，但隐藏了很多复杂性和跨浏览器时的不一致性</strong>，更易于在React框架中使用。在 <code>oh-my-kanban</code> 出现过的受控组件，就是合成事件的重要使用场景之一。此外，我们还会利用其他合成事件为看板卡片加入拖拽功能，顺便了解一下合成事件的冒泡捕获机制。最后，我会介绍一些在React中使用原生DOM事件的场景。</p><!-- [[[read_end]]] --><h2>什么是React合成事件？</h2><p>如果你很熟悉原生DOM事件的使用，那你应该很熟悉这种写法：</p><pre><code class="language-xml">&lt;!-- 这是HTML不是JSX --&gt;
&lt;button onclick="handleClick()"&gt;按钮&lt;/button&gt;
&lt;input type="text" onkeydown="handleKeyDown(event)" /&gt;
</code></pre><p>在React中，HTML元素也有类似的、以 <code>on*</code> 开头的<strong>事件处理属性。</strong>最直接的不同是，这些属性的命名方式遵循驼峰格式（camelCase），如<code>onClick</code>、<code>onKeyDown</code>。在JSX中使用这些属性时，需要传入函数，而不能是字符串：</p><pre><code class="language-javascript">const Component = () =&gt; {
  const handleClick = () =&gt; {/* ...省略 */};
  const handleKeyDown = evt =&gt; {/* ...省略 */};
  return (
    &lt;&gt;
      {/* 这次是JSX了 */}
      &lt;button onClick={handleClick}&gt;按钮&lt;/button&gt;
      &lt;input type="text" onKeyDown={evt =&gt; handleKeyDown(evt)} /&gt;
    &lt;/&gt;
  );
};
</code></pre><p>以上面的 <code>button</code> 为例，开发者将 <code>handleClick</code> 函数传入 <code>onClick</code> 属性。在浏览器中，当用户点击按钮时，<code>handleClick</code> 会被调用，无论开发者是否需要，React都会传入一个描述点击事件的对象作为函数的第一个参数。而这个对象就是React中的合成事件（SyntheticEvent）。</p><p>合成事件是原生DOM事件的一种包装，它<strong>与原生事件的接口相同</strong>，根据W3c规范，React内部<strong>规范化</strong>（Normalize）<strong>了这些接口在不同浏览器之间的行为</strong>，开发者不用再担心事件处理的浏览器兼容性问题。</p><h2>合成事件与原生DOM事件的区别</h2><p>包括刚才提到的，对事件接口在不同浏览器行为的规范化，合成事件与原生DOM事件之间也有着一系列的区别。</p><h3>注册事件监听函数的方式不同</h3><p>监听原生DOM事件基本有三种方式。</p><ol>
<li>与React合成事件类似的，以内联方式写在HTML标签中：</li>
</ol><pre><code class="language-xml">&lt;button id="btn" onclick="handleClick()"&gt;按钮&lt;/button&gt;
</code></pre><ol start="2">
<li>在JS中赋值给DOM元素的事件处理属性：</li>
</ol><pre><code class="language-javascript">document.getElementById('btn').onclick = handleClick;
</code></pre><ol start="3">
<li>在JS中调用DOM元素的 <code>addEventListener</code> 方法（需要在合适时机调用 <code>removeEventListener</code> 以防内存泄漏）：</li>
</ol><pre><code class="language-javascript">document.getElementById('btn').addEventListener('click', handleClick);
</code></pre><p>而合成事件不能通过 <code>addEventListener</code> 方法监听，它的JSX写法等同于JS写法：</p><pre><code class="language-javascript">const Button = () =&gt; (&lt;button onClick={handleClick}&gt;按钮&lt;/button&gt;);
// 编译为
const Button = () =&gt; React.createElement('button', {
  onClick: handleClick
}, '按钮');
</code></pre><p>有时我们需要以捕获方式监听事件，在原生事件中以<code>addEventListener</code> 方法加入第三个参数：</p><pre><code class="language-javascript">div.addEventListener('click', handleClick, true);
</code></pre><p>而在React合成事件中，则需要用在事件属性后面加一个 <code>Capture</code> 后缀：</p><pre><code class="language-javascript">() =&gt; (&lt;div onClickCapture={handleClick}&gt;...&lt;/div&gt;);
</code></pre><h3>特定事件的行为不同</h3><p>React合成事件规范化了一些在各个浏览器间行为不一致，甚至是在不同元素上行为不一致的事件，其中有代表性的是 <code>onChange</code> 。</p><p>在Chrome或Firefox中，一个文本框 <code>&lt;input type="text" /&gt;</code> 的 <code>change</code> 事件发生在文本框内容被改变、然后失去焦点的时候。不过，对一个下拉框<code>&lt;select&gt;</code> 的<code>change</code> 事件，Chrome和老版本Firefox（v63以前）就有分歧了，前者每次按下键盘箭头键都会触发 <code>change</code> 事件，但后者只有下拉框失去焦点时才会触发。</p><p>而在React中，<code>&lt;input&gt;</code> 、<code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 三种表单元素的<code>onChange</code> 合成事件被规范成了一致的行为：<strong>在不会导致显示抖动的前提下，表单元素值的改变会尽可能及时地触发这一事件</strong>。</p><p>以文本框为例，同样是输入一句话，合成 <code>change</code> 事件发生的次数要多于原生的次数，在<code>onChange</code> 事件处理函数被调用时，传入的事件对象参数提供的表单元素值也尽可能是最新的。</p><p>顺便提一下，原生 <code>change</code> 事件行为的不一致，只是前端领域浏览器兼容性问题的冰山一角。React这样的框架为我们屏蔽了这些疑难杂症，我们在享受便利的同时，也需要知道框架们在负重前行。</p><p>除了 <code>onChange</code> ，合成事件也规范化了 <code>onBeforeInput</code> 、 <code>onMouseEnter</code> 、 <code>onMouseLeave</code> 、 <code>onSelect</code> 。</p><h3>实际注册的目标DOM元素不同</h3><p>这一点其实并不影响合成事件处理接口的使用，更多是在讲底层实现。</p><p>对于下面这个原生DOM事件，它的当前目标（ <code>event.currentTarget</code> ）是很明确的，就是ID为 <code>btn</code> 的按钮：</p><pre><code class="language-javascript">document.getElementById('btn').addEventListener('click', handleClick);
</code></pre><p>但合成事件就不一样了！</p><p>我们在 <code>oh-my-kanban</code> 的代码，“添加新卡片”的 <code>onClick</code> 事件处理函数 <code>handleAdd</code> 中设个断点，传入的 <code>evt</code> 参数就是一个合成事件，已知通过 <code>evt.nativeEvent</code> 属性，可以得到这个合成事件所包装的原生事件。</p><p>看一下这几个值：</p><pre><code class="language-javascript">evt.currentTarget
evt.target
evt.nativeEvent.currentTarget
evt.nativeEvent.target
</code></pre><p>可以看到，不出意外地，两种事件的 <code>target</code> 都是按钮元素本身，合成事件的 <code>currentTarget</code> 也是按钮元素，这是符合W3c规范的；但原生事件的 <code>currentTarget</code> 不再是按钮，而是React应用的根容器DOM元素 <code>&lt;div id="root"&gt;&lt;/div&gt;</code> ：</p><p><img src="https://static001.geekbang.org/resource/image/48/05/48132e6d34958fd33632ac62aaa0f205.png?wh=1312x712" alt="图片"></p><p>这是因为React使用了<strong>事件代理模式</strong>。React在创建根（ <code>createRoot</code> ）的时候，会在容器上监听所有自己支持的原生DOM事件。当原生事件被触发时，React会根据事件的类型和目标元素，找到对应的FiberNode和事件处理函数，创建相应的合成事件并调用事件处理函数。</p><p>从表层接口上看，合成事件的属性是符合W3C事件规范的，这就屏蔽了不同浏览器原生DOM事件可能产生的不一致。</p><h2>受控组件与表单</h2><p>表单处理是前端领域一个常见需求，在React中也是一个重要场景。我们看一下目前 <code>oh-my-kanban</code> 项目中唯一的表单代码（省略了部分代码）：</p><pre><code class="language-javascript">const KanbanNewCard = ({ onSubmit }) =&gt; {
&nbsp; const [title, setTitle] = useState('');
&nbsp; const handleChange = (evt) =&gt; {
&nbsp; &nbsp; setTitle(evt.target.value);
&nbsp; };
  // ...省略

&nbsp; return (
&nbsp; &nbsp; &lt;li&gt;
&nbsp; &nbsp; &nbsp; &lt;h3&gt;添加新卡片&lt;/h3&gt;
&nbsp; &nbsp; &nbsp; &lt;div&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;input type="text" value={title} onChange={handleChange} /&gt;
&nbsp; &nbsp; &nbsp; &lt;/div&gt;
&nbsp; &nbsp; &lt;/li&gt;
&nbsp; );
};
</code></pre><p>用户在文本框中输入文本时，会触发 <code>onChange</code> 合成事件，调用 <code>handleChange(evt)</code> 函数，<code>handleChange</code> 函数又会将文本框变更后的值保存在组件state <code>title</code> 中，state的变化导致组件重新渲染，文本框的当前值会更新成 <code>title</code> ，与刚才的更新值保持一致。</p><p>可以看出，这一过程形成了一个闭环。这种<strong>以React state为单一事实来源</strong>（Single Source of Truth）<strong>，并用React合成事件处理用户交互的组件，被称为“受控组件”</strong>。</p><p>除了文本框之外，大部分表单元素，包括单选框、多选框、下拉框等都可以做成受控组件。当这些元素组合成一个表单时，开发者可以很容易获取到任一时刻的表单数据，然后进一步做验证、提交到服务器端等操作。</p><p>其实看板新卡片组件里文本框的 <code>onKeyDown</code> ，可以看作是提交表单。用户按回车后， <code>handleKeyDown</code> 函数会通过 <code>onSubmit</code> 属性将表单值传给父组件：</p><pre><code class="language-javascript">const KanbanNewCard = ({ onSubmit }) =&gt; {
&nbsp; const [title, setTitle] = useState('');
&nbsp; const handleChange = (evt) =&gt; {
&nbsp; &nbsp; setTitle(evt.target.value);
&nbsp; };
&nbsp; const handleKeyDown = (evt) =&gt; {
&nbsp; &nbsp; if (evt.key === 'Enter') {
&nbsp; &nbsp; &nbsp; onSubmit(title);
&nbsp; &nbsp; }
&nbsp; };

&nbsp; return (
&nbsp; &nbsp; &lt;li&gt;
&nbsp; &nbsp; &nbsp; &lt;h3&gt;添加新卡片&lt;/h3&gt;
&nbsp; &nbsp; &nbsp; &lt;div&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;input type="text" value={title}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onChange={handleChange} onKeyDown={handleKeyDown} /&gt;
&nbsp; &nbsp; &nbsp; &lt;/div&gt;
&nbsp; &nbsp; &lt;/li&gt;
&nbsp; );
};
</code></pre><p>你也可以选择显式地将这些表单元素集中在一个 <code>&lt;form&gt;</code> 表单里，这样你就可以利用表单的 <code>onSubmit</code> 事件来规范提交表单的时机。但要注意，这里需要禁用掉表单提交事件的默认行为：</p><pre><code class="language-javascript">const Form = () =&gt; {
  // ...省略
  const handleSubmit(evt) {
&nbsp; &nbsp; console.log('表单元素state');
&nbsp; &nbsp; evt.preventDefault();
&nbsp; }
  return (
&nbsp; &nbsp; &lt;form onSubmit={handleSubmit}&gt;
&nbsp; &nbsp; &nbsp; {/* 省略 */}
&nbsp; &nbsp; &nbsp; &lt;input type="submit" value="提交" /&gt;
&nbsp; &nbsp; &lt;/form&gt;
&nbsp; );
};
</code></pre><p>后续课程中还会多次涉及到受控组件和表单处理，我们在此暂不继续展开。</p><h2>合成事件的冒泡与捕获</h2><p>接下来，我们就利用刚学到的React事件处理，上手继续为 <code>oh-my-kanban</code> 添加功能，其间也会涵盖合成事件的冒泡和捕获机制。</p><p>如果你对第3节课末尾提出的需求还有印象，这个坑我们终于要填了。</p><blockquote>
<p>在三个看板列间，还有进一步的交互。</p>
<ol>
<li>对于任意看板列里的任意卡片，可以用鼠标拖拽到其他的看板列；</li>
<li>在释放拖拽时，被拖拽的卡片插入到目标看板列，并从原看板列中移除。</li>
</ol>
</blockquote><p>我们简单分析一下这个需求。将被拖拽的项目是看板卡片，有效的放置目标是看板列，放置成功时会移动这张卡片。这样的交互对应的数据逻辑如下：</p><ul>
<li>被拖拽的卡片对应的数据，是待处理、进行中或已完成数组的其中一个成员；</li>
<li>放置成功时，该成员会从源头数组中移除，同时会添加到目标数组中。</li>
</ul><p>那基本上就可以确定这个需求的实现方法了：</p><ul>
<li>在看板列和看板卡片组件元素上，需要分别监听拖拽事件；</li>
<li>在组件状态中应记录当前被拖拽卡片的数据，以及哪个看板列对应的的数组是拖拽源头，哪个是放置目标。</li>
</ul><p>现在来到 <code>oh-my-kanban</code> 的  <code>src/App.js</code> 文件，让我们先为看板卡片 <code>KanbanCard</code> 组件的 <code>&lt;li&gt;</code> 元素添加 <code>draggable</code> 和  <code>onDragStart</code> 属性：</p><p><img src="https://static001.geekbang.org/resource/image/1a/5e/1ae98dab2e8c52b056db2678fc26ed5e.png?wh=1318x776" alt="图片"></p><p>然后为看板列KanbanColumn组件的 <code>&lt;section&gt;</code> 元素添加 <code>onDragOver</code> 、 <code>onDragLeave</code>、<code>onDrop</code> 、<code>onDragEnd</code> 属性：</p><pre><code class="language-javascript">const KanbanColumn = ({ children, bgColor, title }) =&gt; {
&nbsp; return (
&nbsp; &nbsp; &lt;section
&nbsp; &nbsp; &nbsp; onDragOver={(evt) =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; evt.preventDefault();
&nbsp; &nbsp; &nbsp; &nbsp; evt.dataTransfer.dropEffect = 'move';
&nbsp; &nbsp; &nbsp; }}
&nbsp; &nbsp; &nbsp; onDragLeave={(evt) =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; evt.preventDefault();
&nbsp; &nbsp; &nbsp; &nbsp; evt.dataTransfer.dropEffect = 'none';
&nbsp; &nbsp; &nbsp; }}
&nbsp; &nbsp; &nbsp; onDrop={(evt) =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; evt.preventDefault();
&nbsp; &nbsp; &nbsp; }}
&nbsp; &nbsp; &nbsp; onDragEnd={(evt) =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; evt.preventDefault();
&nbsp; &nbsp; &nbsp; }}
&nbsp; &nbsp; &nbsp; css={css`...省略`}
&nbsp; &nbsp; &gt;
&nbsp; &nbsp; &nbsp; &lt;h2&gt;{title}&lt;/h2&gt;
&nbsp; &nbsp; &nbsp; &lt;ul&gt;{children}&lt;/ul&gt;
&nbsp; &nbsp; &lt;/section&gt;
&nbsp; );
};
</code></pre><p>这时在浏览器里已经可以拖拽卡片了，但放置时貌似没什么反应，动图展示如下：</p><p><img src="https://static001.geekbang.org/resource/image/a9/79/a9b0e4de6cb7bd81ddf0f703d4e58f79.gif?wh=760x500" alt="图片"></p><p>接下来，需要在根部的 <code>App</code> 组件里创建三个新的state，分别是 <code>draggedItem</code> 、 <code>dragSource</code> 、 <code>dragTarget</code> ，以及作为<code>dragSource</code> 和 <code>dragTarget</code> 枚举值的三个 <code>COLUMN_KEY_*</code> 常量：</p><p><img src="https://static001.geekbang.org/resource/image/f0/36/f08c321e374ca582d4b86bd29973df36.png?wh=1378x968" alt="图片"></p><p>这时我们需要在看板卡片 <code>KanbanCard</code> 组件 <code>onDragStart</code> 事件中更新 draggedItem状态的值，但这个state是在App组件中维护的，那么如何才能让KanbanCard修改它呢？</p><p>是的，跟之前的onSubmit一样，将更新函数通过props传给KanbanCard，KanbanCard会在内部的onDragStart中调用它：</p><p><img src="https://static001.geekbang.org/resource/image/b6/ae/b667ca3abedf86f4f3420b20a4255dae.png?wh=886x1260" alt="图片"></p><p>上面代码只展示了todoList，另外两个组件列，也就是ongoingList和doneList也要做相同处理，你可以自己上手试一试。</p><p>然后来看，如何在看板列KanbanColumn中设置<code>dragSource</code> 和 <code>dragTarget</code> 。</p><p>为了让KanbanColumn内部的逻辑更清晰些，我没有把<code>dragSource</code> 和 <code>dragTarget</code> 直接传给KanbanColumn，而是为它添加了两个修改布尔值的函数props，也就是setIsDragSource 和 setIsDragTarget：</p><p><img src="https://static001.geekbang.org/resource/image/ea/a2/ea2daa062e09eefa03bfdf1baa3be6a2.png?wh=862x1156" alt="图片"></p><p>上面的KanbanCard的代码中，<code>&lt;li&gt;</code> 已经监听过 <code>onDragStart</code> 事件，在KanbanColumn的 <code>&lt;section&gt;</code> 中是第二次出现了。在运行时，由于HTML元素的<code>onDragStart</code> 事件在触发后会<strong>冒泡</strong>（Event Bubbling）到祖先元素，所以这两个事件处理函数都会执行。</p><p>对应的，在App组件中需要设置这些props：</p><pre><code class="language-diff"> const DATA_STORE_KEY = 'kanban-data-store';
 const COLUMN_KEY_TODO = 'todo';
 const COLUMN_KEY_ONGOING = 'ongoing';
 const COLUMN_KEY_DONE = 'done';

 function App() {
 &nbsp; // ...省略
 &nbsp; const [draggedItem, setDraggedItem] = useState(null);
 &nbsp; const [dragSource, setDragSource] = useState(null);
 &nbsp; const [dragTarget, setDragTarget] = useState(null);

&nbsp;  return (
     {/* 省略 */}
-&nbsp; &nbsp; &lt;KanbanColumn bgColor={COLUMN_BG_COLORS.todo} title={
 &nbsp; &nbsp; &nbsp; /* ... */
-&nbsp; &nbsp; }&gt;
+&nbsp; &nbsp; &lt;KanbanColumn
+&nbsp; &nbsp; &nbsp; bgColor={COLUMN_BG_COLORS.todo}
+&nbsp; &nbsp; &nbsp; title={
 &nbsp; &nbsp; &nbsp; &nbsp; /* ... */
+&nbsp; &nbsp; &nbsp; }
+&nbsp; &nbsp; &nbsp; setIsDragSource={(isSrc) =&gt; setDragSource(isSrc ? COLUMN_KEY_TODO : null)}
+&nbsp; &nbsp; &nbsp; setIsDragTarget={(isTgt) =&gt; setDragTarget(isTgt ? COLUMN_KEY_TODO : null)}
+&nbsp; &nbsp; &gt;
</code></pre><p>以上的代码只展示了待处理列的改法，进行中和已完成两列分别对应常量COLUMN_KEY_ONGOING和COLUMN_KEY_DONE，需要请你补全它们的setIsDragSource 和 setIsDragTarget。</p><p>这时我们借助React Developer Tools看看拖拽是如何修改state的，动图效果展示如下：</p><p><video poster="https://media001.geekbang.org/795793366c4e4ea3bcfb9ad275523354/snapshots/03252dc0108f4e219ac8b33e07da2337-00002.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/279b1130-183405a3c16-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/3527a58b0e12488d91706622fcab252b/5665d21cdfe14547b65862952206da53-da09f8590e67a7f17ee4980a98ee9abf-sd.m3u8" type="application/x-mpegURL"></video></p><p>赞，符合预期。好了，最后也是最重要的一步，是加入onDrop的数据处理逻辑。首先是KanbanColumn追加一个onDrop属性：</p><pre><code class="language-diff"> const KanbanColumn = ({
   children,
   bgColor,
   title, 
   setIsDragSource = () =&gt; {},
   setIsDragTarget = () =&gt; {},
+  onDrop
 }) =&gt; {
 &nbsp; return (
&nbsp;  &nbsp; &lt;section
       onDragStart={() =&gt; setIsDragSource(true)}
&nbsp; &nbsp; &nbsp;  onDragOver={(evt) =&gt; {
&nbsp; &nbsp; &nbsp;  &nbsp; evt.preventDefault();
&nbsp; &nbsp; &nbsp;  &nbsp; evt.dataTransfer.dropEffect = 'move';
         setIsDragTarget(true);
&nbsp; &nbsp;  &nbsp; }}
&nbsp; &nbsp;  &nbsp; onDragLeave={(evt) =&gt; {
&nbsp; &nbsp; &nbsp;  &nbsp; evt.preventDefault();
&nbsp; &nbsp; &nbsp;  &nbsp; evt.dataTransfer.dropEffect = 'none';
         setIsDragTarget(false);
&nbsp; &nbsp; &nbsp;  }}
&nbsp; &nbsp;  &nbsp; onDrop={(evt) =&gt; {
&nbsp; &nbsp;  &nbsp; &nbsp; evt.preventDefault();
+        onDrop &amp;&amp; onDrop(evt);
&nbsp;  &nbsp; &nbsp; }}
&nbsp; &nbsp; &nbsp;  onDragEnd={(evt) =&gt; {
&nbsp; &nbsp; &nbsp;  &nbsp; evt.preventDefault();
         setIsDragSource(false);
         setIsDragTarget(false);
&nbsp; &nbsp;  &nbsp; }}
&nbsp;  &nbsp; &nbsp; css={css`...省略`}
&nbsp;  &nbsp; &gt;
&nbsp;  &nbsp; &nbsp; &lt;h2&gt;{title}&lt;/h2&gt;
&nbsp;  &nbsp; &nbsp; &lt;ul&gt;{children}&lt;/ul&gt;
&nbsp;  &nbsp; &lt;/section&gt;
&nbsp;  );
 };
</code></pre><p>然后在App组件中定义handleDrop函数，当前面的三个state满足条件时，修改源数组和目标数组，通过onDrop属性把同一个函数分别传递给三个KanbanColumn。</p><p>在这里，为了减少代码重复，我在函数内部给三个数组的更新函数套了一个索引对象：</p><pre><code class="language-javascript">const COLUMN_KEY_TODO = 'todo';
const COLUMN_KEY_ONGOING = 'ongoing';
const COLUMN_KEY_DONE = 'done';

function App() {
&nbsp; const [showAdd, setShowAdd] = useState(false);
&nbsp; const [todoList, setTodoList] = useState([/*省略*/]);
&nbsp; const [ongoingList, setOngoingList ] = useState([/*省略*/]);
&nbsp; const [doneList, setDoneList ] = useState([/*省略*/]);
&nbsp; // 省略
  const handleSubmit = (title) =&gt; {/*省略*/};
  const [draggedItem, setDraggedItem] = useState(null);
&nbsp; const [dragSource, setDragSource] = useState(null);
&nbsp; const [dragTarget, setDragTarget] = useState(null);
&nbsp; const handleDrop = (evt) =&gt; {
&nbsp; &nbsp; if (!draggedItem || !dragSource || !dragTarget || dragSource === dragTarget) {
&nbsp; &nbsp; &nbsp; return;
&nbsp; &nbsp; }
&nbsp; &nbsp; const updaters = {
&nbsp; &nbsp; &nbsp; [COLUMN_KEY_TODO]: setTodoList,
&nbsp; &nbsp; &nbsp; [COLUMN_KEY_ONGOING]: setOngoingList,
&nbsp; &nbsp; &nbsp; [COLUMN_KEY_DONE]: setDoneList
&nbsp; &nbsp; }
&nbsp; &nbsp; if (dragSource) {
&nbsp; &nbsp; &nbsp; updaters[dragSource]((currentStat) =&gt;
&nbsp; &nbsp; &nbsp; &nbsp; currentStat.filter((item) =&gt; !Object.is(item, draggedItem))
&nbsp; &nbsp; &nbsp; );
&nbsp; &nbsp; }
&nbsp; &nbsp; if (dragTarget) {
&nbsp; &nbsp; &nbsp; updaters[dragTarget]((currentStat) =&gt; [draggedItem, ...currentStat]);
&nbsp; &nbsp; }
&nbsp; };

  return (
  &nbsp; &lt;div className="App"&gt;
      {/* 省略 */}
  &nbsp; &nbsp; &lt;KanbanColumn
&nbsp; &nbsp; &nbsp; &nbsp; bgColor={COLUMN_BG_COLORS.ongoing}
&nbsp; &nbsp; &nbsp; &nbsp; title="进行中"
&nbsp; &nbsp; &nbsp; &nbsp; setIsDragSource={(isDragSource) =&gt; setDragSource(isDragSource ? COLUMN_KEY_ONGOING : null)}
&nbsp; &nbsp; &nbsp; &nbsp; setIsDragTarget={(isDragTarget) =&gt; setDragTarget(isDragTarget ? COLUMN_KEY_ONGOING : null)}
&nbsp; &nbsp; &nbsp; &nbsp; onDrop={handleDrop}
&nbsp; &nbsp; &nbsp; &gt;
      {/* 省略 */}
    &lt;/div&gt;
  );
}
</code></pre><p>现在让我们在浏览器中看看效果，动态展示如下：</p><p><img src="https://static001.geekbang.org/resource/image/5b/df/5b5940cd32811372206ce3e9789155df.gif?wh=1200x696" alt="图片"></p><p>恭喜你，大功告成！到目前为止，这个看板的功能总算是形成一个闭环了。这么重要的里程碑，请你务必提交到你的代码仓库里（也欢迎把你的代码链接分享在留言区）。</p><p>不过，刚才我们提到了合成事件的事件冒泡，你可能会问，那有<strong>事件捕获（Event Capture）</strong>的例子吗？你可以把src/App.js文件中的 <code>onDragStart</code> 全局替换成 <code>onDragStartCapture</code> ，然后看看效果。</p><p>其实从交互上看不出区别，只是两个组件对应的事件处理函数的执行顺序颠倒了过来。关于事件冒泡和事件捕获的使用场景，后续的课程中还会涉及到。</p><h2>什么时候使用原生DOM事件？</h2><p>一般情况下，React的合成事件已经能满足你的大部分需求了，有两种情况例外。</p><ol>
<li>需要监听React组件树之外的DOM节点的事件，这也包括了window和document对象的事件。注意注意的是，在组件里监听原生DOM事件，属于典型的副作用，所以请务必在useEffect中监听，并在清除函数中及时取消监听。如：</li>
</ol><pre><code class="language-javascript">useEffect(() =&gt; {
  window.addEventListener('resize', handleResize);
  return function cleanup() {
    window.removeEventListener('resize', handleResize);
  };
}, []);
</code></pre><ol start="2">
<li>很多第三方框架，尤其是与React异构的框架，在运行时会生成额外的DOM节点。在React应用中整合这类框架时，常会有非React的DOM侵入React渲染的DOM树中。当需要监听这类框架的事件时，要监听原生DOM事件，而不是React合成事件。这同样也是useEffect或useLayoutEffect的领域。<br>
当然，只要你知道原理，也完全可以用原生DOM事件加上一些特殊处理来替代合成事件，但这种做法就没那么“React”了。</li>
</ol><h2>小结</h2><p>这节课我们介绍了React合成事件，知道了合成事件是原生DOM事件的一种规范化的封装，也了解了它在注册监听方式、onChange等特定事件的行为、实际注册的目标DOM这三个方面与原生DOM事件的区别。</p><p>然后在oh-my-kanban代码基础上，我们进一步学习了受控组件和表单处理，也上手为看板加入了卡片拖拽的功能，并顺路实践了合成事件的事件冒泡和事件捕获。</p><p>最后，我们还列举了一些合成事件力不能及，必须监听原生DOM事件的场景。按照老规矩，这里我也附上本节课所涉及的项目源代码：<a href="https://gitee.com/evisong/geektime-column-oh-my-kanban/releases/tag/v0.11.0">https://gitee.com/evisong/geektime-column-oh-my-kanban/releases/tag/v0.11.0</a></p><p>下节课我们将迎来组件逻辑开发的重头戏——单向数据流，了解数据如何在React组件中流转，学习如何设计和操控React应用的数据流。</p><h2>思考题</h2><ol>
<li>这节课我们讲到了合成事件的事件冒泡和事件捕获，我想请你设计一些实验，来验证事件处理函数在父子组件间的执行顺序。另外，我们也提到了在事件处理函数中可以通过调用 <code>event.stopPropogation()</code> 来阻止事件进一步冒泡或捕获，请你思考一下什么场景下会用到。</li>
<li>我们时不时也回来关注一下性能，我想请你在React Developer Tools中打开“组件渲染时高亮变化”。然后观察一下在拖拽操作期间，都有哪些组件做了无谓的渲染。<br>
<img src="https://static001.geekbang.org/resource/image/f5/33/f53edef52dd7171db3c0766f9fyyf533.png?wh=1312x812" alt="图片"></li>
</ol><p>欢迎把你的思考和想法分享在评论区，我们下节课再见！</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>🐑</span>
  </div>
  <div class="_2_QraFYR_0">你好，我是《现代React Web开发实战》的编辑辰洋，这是👇项目的源代码链接，供你学习与参考：https:&#47;&#47;gitee.com&#47;evisong&#47;geektime-column-oh-my-kanban&#47;releases&#47;tag&#47;v0.11.0</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-19 19:41:22</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/2c/a5/f4/9bf287ea.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>WL</span>
  </div>
  <div class="_2_QraFYR_0">感觉老师讲得过于多内容了，看着挺花时间；可以简化些就更好了</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，WL，感谢你的反馈。目前这个专栏的整体，还有每节课的局部，基本都是按照表层-底层-表层-底层逻辑设计的，每节课设计的内容密度与这套逻辑相关。我和专栏编辑也商量过，在不改变课程总体设计的前提下，我们会尽量平衡各位同学的学习需求。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-15 21:00:06</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/e7/20/70a95f94.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>潮汐</span>
  </div>
  <div class="_2_QraFYR_0">老师，想问一下，这节课的拖拽的例子，你的拖拽开始的时候，卡片会不会有一闪而过的卡片时间从status的时间变成相对时间的画面。分析了下，感觉像是KanbanCard的setDraggedItem触发了App的更新渲染，KanbanColumn和KanbanCard也会被重新渲染。但是draggedItem也并没有传给KanbanCard，为啥会触发KanbanCard的协调更新呢。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，潮汐，我用 https:&#47;&#47;gitee.com&#47;evisong&#47;geektime-column-oh-my-kanban&#47;releases&#47;tag&#47;v0.11.0 的代码在本地跑了一下，没观察到你说的情况，请问你使用的 git commit id 和浏览器版本是怎样的？</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2023-01-08 14:03:47</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>阿阳</span>
  </div>
  <div class="_2_QraFYR_0">每节课的内容好多，全是干货。需要反复的听，看，动手实践。请问老师，每节课的课后习题有没有专门的章节做解答啊？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，阿阳，感谢你的认可，衷心希望你从本专栏中有所收获。<br><br>专栏每节课课后都有1～2个思考题，初衷是为了鼓励同学们思考、讨论，提升学习效果。可以看到在每节课的留言区，已经有了不少优秀的答案，一些答案下面有我的评论，也有部分答案引起了同学们的热烈讨论。<br><br>在连载期间，根据同学们的留言，我们也选了3个主题制作上线了两节加餐：《加餐01｜留言区心愿单：真·子组件以及jsx-runtime》和《加餐02｜留言区心愿单：Fiber协调引擎》。目前虽然连载已经告一段落，还是非常欢迎同学们留言参与互动，我们也会根据同学们的需求，考虑是否额外加餐。<br><br>在此也感谢所有参与互动的同学们，谢谢你们！</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-11-29 14:59:11</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/5c/31/d7b92b6b.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>癡癡的等你歸</span>
  </div>
  <div class="_2_QraFYR_0">老师，课程源码不见了，404了</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，癡癡的等你歸，你说的源码链接是下面这个吗？<br><br>    https:&#47;&#47;gitee.com&#47;evisong&#47;geektime-column-oh-my-kanban&#47;releases&#47;tag&#47;v0.11.0<br><br>我用电信宽带和联通5G都试了试，目前都能正常访问（虽然后者有点慢）。请再试试，如果还是不行请告诉我们你的电信提供商和连接方式，我会请Gitee排查。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-11-16 16:06:33</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/15/b9/d8/92c2b3ab.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>海华呀</span>
  </div>
  <div class="_2_QraFYR_0">1、执行顺序 是父-子-父，有些洋葱圈模型的感觉 <br>&lt;div onClickCapture={() =&gt; console.log(1)} onClick={() =&gt;console.log(4)} &gt;<br>      &lt;p onClickCapture={() =&gt; console.log(2)} onClick={() =&gt; { console.log(3) }}&gt;<br>        target<br>      &lt;&#47;p&gt;<br>    &lt;&#47;div &gt; <br>例如这个点击会依次打印出1、2、3、4；<br>阻止冒泡 一般是父子组件都对事件做了处理，例如 文章列表页 ，点赞按钮，和打开详情页面；<br></div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，海华呀，很简洁有效的实验，赞！</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-18 23:11:48</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Geek_8e9c8d</span>
  </div>
  <div class="_2_QraFYR_0">已经开始期待以后开的项目课了<br>希望能得到省份和城市的那个思考题的更多提示~,谢谢</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，Geek_8e9c8d，抱歉由于之前一直在赶稿，这么久才回复。第24节课的特别企划开源项目在：<br><br>    https:&#47;&#47;gitee.com&#47;evisong&#47;geektime-column-oh-my-kit<br><br>很快就会正式运转起来，非常期待你的加入。<br><br>关于第10节课省份+城市的思考题，基本知识点就是那个依赖值数组。文稿中的代码：<br><br>    &#47;&#47;   ------------   --------------<br>    &#47;&#47;   | 省份... |v|   | 城市...  |v|<br>    &#47;&#47;   ------------   --------------<br><br>    const [province, setProvince] = useState(null);<br>    const [cities, setCities] = useState([]);<br>    useEffect(() =&gt; {<br>      if (province === &#39;山东&#39;) {<br>        &#47;&#47; 这些数据可以是本地数据，也可以现从服务器端读取<br>        setCities([&#39;济南&#39;, &#39;青岛&#39;, &#39;淄博&#39;]);<br>      }<br>    }, [province]);<br><br>意思就是当 province值有变化才会再次执行前面的副作用回调函数，来更新城市列表state。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-10 20:09:55</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/19/64/6f2b7b86.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>01</span>
  </div>
  <div class="_2_QraFYR_0">对目前发展来讲， 合成事件是否是个好的选择。 同时是否增加了开发的心智负担。 许多类react相关库不采用合成事件代替原生事件。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，01，这是个好问题。我也赞同合成事件增加了开发者的认知负担。不过我也会从下面几个方面思考合成事件对于React的必要性：<br><br>1. React对事件系统的限制。对于DOM event，只要开发者愿意，可以做到很多替代React数据流的事情，而合成事件，则只保留了主要是与用户交互相关的部分能力，保证它不会跟React其他特性抢活儿。<br><br>2. 合成事件对于特定事件的所谓规范化，尤其是onChange，算是受控组件的基本实现原理，如果放手给原生DOM事件，受控组件方案可能需要调整。<br><br>3. 原生DOM event的事件处理是同步执行的，可能会阻塞页面，我本想对比一下合成事件处理是不是异步执行的，但我查过React源码packages&#47;react-dom&#47;src&#47;events&#47;和一些资料，还没有发现有地方说明这一点。<br><br>4. 在React 17，合成事件处理函数中修改多次state，会自动批处理，只触发一次渲染，原生DOM事件处理函数中如果也修改多个state，是不享受这个待遇的；不过这个优势在React 18已经不存在了，只要是事件处理函数中，都可以自动批处理，只渲染一次：<br><br>elm.addEventListener(&#39;click&#39;, () =&gt; {<br>  setCount(c =&gt; c + 1);<br>  setFlag(f =&gt; !f);<br>  &#47;&#47; React will only re-render once at the end (that&#39;s batching!)<br>});<br><br>具体可以参考 https:&#47;&#47;github.com&#47;reactwg&#47;react-18&#47;discussions&#47;21<br><br>如有补充或其他观点，欢迎继续回复讨论。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-27 22:45:46</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/17/a8/1e/4ec85e24.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>joel</span>
  </div>
  <div class="_2_QraFYR_0">还没有更吗</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-16 14:06:38</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/17/a8/1e/4ec85e24.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>joel</span>
  </div>
  <div class="_2_QraFYR_0">终于追上来了</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，joel，我看了下你留言的日期，学习速度快得让人羡慕 :) 很高兴专栏能引起你的学习兴趣。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-15 11:44:13</div>
  </div>
</div>
</div>
</li>
</ul>