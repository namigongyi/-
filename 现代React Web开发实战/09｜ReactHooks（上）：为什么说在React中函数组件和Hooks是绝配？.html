<audio title="09｜ReactHooks（上）：为什么说在React中函数组件和Hooks是绝配？" src="https://static001.geekbang.org/resource/audio/e9/89/e98b53488b348f50b741eb04bd1a9e89.mp3" controls="controls"></audio> 
<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>上节课我们学习了React组件的生命周期，包括组件层面的挂载、更新、卸载、错误处理四个阶段，以及框架层面的渲染和提交这两个阶段。</p><p>在这些阶段中，我们列举了类组件的 <code>render</code>、<code>componentDidMount</code>、<code>componentWillUnmount</code> 等生命周期方法，以及这些方法执行的先后顺序，也对比了函数组件中的Hooks是如何参与组件生命周期的。最后，我们利用 <code>useEffect</code> Hooks函数，为 <code>oh-my-kanban</code> 项目新加了一个定时更新卡片显示时间的功能。</p><p>敏锐的你可能发现了，上节课中你只为函数组件写了Hooks代码，而类组件的生命周期方法仅是介绍而已。还有就是截止目前，<code>oh-my-kanban</code>项目里只有函数组件，一个类组件都没有——同样是组件，类组件怎么就被区别对待了呢？其实不是类组件掉了链子，只是函数组件加Hooks这对黄金搭档后来居上，抢了类组件的风头。</p><p>接下来你可能还会有疑问：</p><ul>
<li>Hooks到底是什么？怎么用？</li>
<li>函数组件加Hooks可以完全替代类组件吗？</li>
<li>还有必要学习类组件吗？</li>
</ul><p>这节课和下节课，我们将学习React自v16.8.0版本加入的Hooks API。当你完成这两节课的学习，相信在掌握Hooks使用的同时，也会对函数组件和类组件在今后React应用开发中的地位，拥有自己的独立判断。</p><!-- [[[read_end]]] --><h2>什么是Hooks？</h2><p>Hooks是React实现组件逻辑的重要方式，可以用来操作state，定义副作用，更支持开发者自定义Hooks。Hooks借鉴自函数式编程，但同时在使用上也有一些限制。</p><p>接下来，我们不妨借助函数式编程中纯函数和副作用这两个概念，来理解什么是Hooks。</p><p>React对UI的<strong>理想模型是</strong> <code>UI=f(state)</code><strong>，其中UI是视图，state是应用状态，f则是渲染过程</strong>。比起类组件，<strong>函数组件更加贴近这一模型</strong>，但从功能来看，早期的函数组件功能与类组件仍有不小差距。</p><p>在React v0.14、v15、v16（v16.8.0之前）版本时，先后有mix-in、高阶组件、recompose框架被用来弥补这个差距。直到官方在v16.8.0推出Hooks，函数组件所缺少的一块拼图终于补齐了。</p><p>这里提一下<strong>纯函数</strong>（Pure Function）的概念。当一个函数满足如下条件时，就可以被认为是纯函数：</p><ol>
<li>函数无论被调用多少次，只要参数相同，返回值就一定相同，这一过程不受外部状态或者IO操作的影响；</li>
<li>函数被调用时不会产生<strong>副作用</strong>（Side Effect），即不会修改传入的引用参数，不会修改外部状态，不会触发IO操作，也不会调用其他会产生副作用的函数。</li>
</ol><p>下面这段JS代码就是一个最简单的纯函数，对于给定的 <code>a</code> 和 <code>b</code>，返回值永远是两者之和：</p><pre><code class="language-javascript">const func = (a, b) =&gt; {
  return a + b;
};
</code></pre><p>用纯函数的概念来分析下面的React函数组件，对于给定的props <code>a</code>和<code>b</code>，每次渲染时都会返回相同的无序列表元素：</p><pre><code class="language-javascript">const Component = ({ a, b }) =&gt; {
  return (
    &lt;ul&gt;
      &lt;li&gt;{a}&lt;/li&gt;
      &lt;li&gt;{b}&lt;/li&gt;
    &lt;/ul&gt;
  );
};
</code></pre><p>虽然React官方并没有类似的提法，但为了方便理解，我们姑且把这样用纯函数的方式编写的React组件称作<strong>“纯函数组件”。</strong>编写纯函数组件，<strong>可以最直观地展示输入的props与输出的渲染元素之间的关系，非常利于开发者把握组件的层次结构和样式。</strong></p><p>但需要知道，这样的纯函数组件除了props、JSX外，几乎不能使用React组件的所有其他特性——<strong>对于纯函数组件来说，这些其他特性全部都是外部状态或副作用</strong>。</p><p>反过来说，若想让函数组件使用这些其他特性，只要让它以某种方式，显式地访问函数的外部状态（应限制在React框架的范围以内，所以对React而言是内部状态），或者执行副作用就好了。</p><p><strong>Hooks就是这样一套为函数组件设计的，用于访问React内部状态或执行副作用操作，以函数形式存在的React API</strong>。注意，这里提到的“React内部状态”是比组件state更广义的统称，除了state外，还包括后面课程中会详细讲解的context、memo、ref等。</p><p>作为例子，我们在上面的“纯函数组件”代码中加入Hooks。<code>useState</code> 这一Hook会读取或存储组件的state，加入它，让函数组件具有了操作state的能力：</p><pre><code class="language-javascript">const Component = ({ a, b }) =&gt; {
  const [m, setM] = useState(a); // 一个Hook
  const [n, setN] = useState(b); // 另一个Hook
  return (
    &lt;ul&gt;
      &lt;li&gt;{m}&lt;button onClick={() =&gt; setM(m + 1)}&gt;+&lt;/button&gt;&lt;/li&gt;
      &lt;li&gt;{n}&lt;button onClick={() =&gt; setN(n + 1)}&gt;+&lt;/button&gt;&lt;/li&gt;
    &lt;/ul&gt;
  );
};
</code></pre><p>要注意一点，组件的state并不是绑定在组件的函数上的，而是组件渲染产生的虚拟DOM节点，也就是 <code>FiberNode</code> 上的。所以在上面的函数中调用 <code>useState</code> ，意味着函数将访问函数本身以外、React以内的状态，这就让函数产生了副作用，导致函数不再是纯函数，也意味着函数组件不再是“纯函数组件”。</p><p>但我们从来没有强求过组件函数必须是纯函数，不是吗？加入Hooks的函数组件不再纯粹，但更强大，变得可以使用包含state在内的、React的大部分特性。纯函数、外部状态和副作用这些概念，可以成为我们学习使用Hooks的参照物，也更方便我们理解、分析React组件。</p><p>此外多提一下，在React里有个概念叫“纯组件”，但我们却不能把上面的“纯函数组件”等同于“纯组件”。因为在React里，<strong>纯组件PureComponent</strong>是一个主要用于性能优化的独立API：<strong>当组件的props和state没有变化时，将跳过这次渲染</strong>，直接沿用上次渲染的结果。</p><p>而上面的<strong>函数组件，每次在渲染阶段都会被执行</strong>，如果返回的元素树经过协调引擎比对后，与前一次的没有差异，则在提交阶段不会更新对应的真实DOM。</p><h2>React Hooks有哪些？</h2><p>了解了什么是Hooks，我们再来看看都有哪些Hooks。React v18.2.0提供的基础Hooks包括三个：</p><ol>
<li>useState</li>
<li>useEffect</li>
<li>useContext</li>
</ol><p>其他Hooks，有些是上面基础Hooks的变体，有些虽然用途不同，但与基础Hooks共享底层实现。包括十个：</p><ol>
<li>useReducer</li>
<li>useMemo</li>
<li>useCallback</li>
<li>useRef</li>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
<li>useDebugValue</li>
<li>useDeferredValue</li>
<li>useTransition</li>
<li>useId</li>
</ol><p>此外还有为第三方库作者提供的 <code>useSyncExternalStore</code> 和 <code>useInsertionEffect</code> 。虽然React API中提供了这么多Hooks，但并不意味着你每个Hook都要精通。</p><p>我的建议是，首先精通三个基础Hooks，也就是 <code>useState</code> 、 <code>useEffect</code> 和 <code>useContext</code>。然后在此基础上：</p><ol>
<li>掌握 <code>useRef</code> 的一般用法；</li>
<li>当需要优化性能，减少不必要的渲染时，学习掌握 <code>useMemo</code> 和 <code>useCallback</code> ；</li>
<li>当需要在大中型React项目中处理复杂state时，学习掌握 <code>useReducer</code> ；</li>
<li>当需要封装组件，对外提供命令式接口时，学习掌握 <code>useRef</code> 加 <code>useImperativeHandle</code>；</li>
<li>当页面上用户操作直接相关的紧急更新（Urgent Updates，如输入文字、点击、拖拽等），受到异步渲染拖累而产生卡顿，需要优化时，学习掌握 <code>useDeferredValue</code> 和 <code>useTransition</code> 。</li>
</ol><p>其中基础Hooks的 <code>useState</code> 和 <code>useEffect</code> ，我们分别会在这节课和下节课详细讲解，<code>useContext</code> 涉及到Context，我们留到12～13节课再展开。</p><p>基础Hooks之外，<code>useRef</code> 也是用来操作数据的，而且相对独立，我们放在这节课末尾来讲。<code>useMemo</code> 和 <code>useCallback</code> 在接口形式上与useEffect有相似之处，一并放到下节课介绍。</p><p>课程篇幅有限，一些不常用或者过于新的Hooks我们暂不涉及，你如果感兴趣的话请参考<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">React官方Hooks文档</a>。下面我们先来学习 <code>useState</code> 和它的伙伴们。</p><h2>状态Hooks</h2><p>在上面列举的Hooks中，操作state的Hook包括<strong>基础的</strong> <code>useState</code> <strong>和它的变体</strong> <code>useReducer</code> ，我们马上会学习到。多提一下，其中 <code>useState</code> 是所有Hooks中<strong>最</strong>常用的（没有之一，遥遥领先），之所以说最常用，是因为开发者经常在一个组件里写多个 <code>useState</code> 来操作多个state。</p><p>我们下面将会讲解的React 18加入的<strong>自动批处理多个state更新</strong>的功能，也印证了React官方是鼓励这种用例。</p><h3>useState</h3><p>如果你还有印象，我们这个课程里第一次出现 <code>useState</code> 是在第三节课，回忆一下那个不太严谨但很方便的说法：<strong>在组件内部改变state会让组件重新渲染</strong>。</p><p>是的，useState就是用来操作组件state的Hook。<code>oh-my-kanban</code>项目 <code>App</code> 组件的代码中第一句就是在创建名为 <code>showAdd</code> 的state：</p><pre><code class="language-javascript">import React, { useState } from 'react';
// ...省略
function App() {
  const [showAdd, setShowAdd] = useState(false);
  //     -------  ----------             -----
  //        ^         ^                    ^
  //        |         |                    |
  //    state变量  state更新函数           state初始值
  const [todoList, setTodoList] = useState([/* ...省略 */]);
</code></pre><p>在组件挂载时，组件内会创建一个新的state，初始值为 <code>false</code>。<code>useState</code> 函数的返回值是一个包含两个成员的数组，通过ES2015的数组解构语法（ <code>[</code> <code>]</code> ）可以得到一个变量和一个函数。</p><p>组件代码可以通过 <code>showAdd</code> 变量读取这个state，当需要更新这个state时，则调用 <code>setShowAdd</code> 函数，如 <code>setShowAdd(true)</code> 。每次组件更新，在渲染阶段都会再次调用这个<code>useState</code> 函数，但它不会再重新初始化state，而是保证 <code>showAdd</code> 值是最新的。</p><p>上面组件的第二行语句创建了另一个名为 <code>todoList</code> 的state，调用 <code>setTodoList</code> 更新state只会更新 <code>todoList</code> ，不会影响到前面的 <code>showAdd</code>。</p><p>其实无论 <code>showAdd</code> 还是 <code>todoList</code>，都只是单纯的变量名而已，真正决定它们是两个相互独立的state的，是 <code>useState</code> 的<strong>调用次数和顺序</strong>。你可以自行决定state变量名和state更新函数名，<code>xxx</code> 和 <code>setXxx</code> 只是个约定俗成的命名法。</p><p>上面提到每次组件更新都会调用<code>useState</code> ，这其实是有性能隐患的。你可能好奇，<code>useState(false)</code>  得调用多少次才能影响到性能啊？而且，不是说它不会再重新初始化state吗？</p><p>确实，框架提供的 <code>useState</code> 本身不会这么弱的。不过，<code>useState</code> 的参数就不一定了。现在的参数是一个简单的布尔值，但如果它是一个复杂的表达式呢？每次组件更新执行渲染时，即使这个表达式的值不会被 <code>useState</code> 再次使用，但表达式本身还是会被执行的。</p><p>不妨请你写个简单的斐波那契数列递归函数，然后把执行结果当作参数： <code>useState(fibonacci(40))</code> ，然后性能肉眼可见地变差了，表达式执行的成本太高了（当然你可以优化函数本身的算法）。但没关系，<code>useState</code> 还有另一种设置默认值的方法，就是传一个函数作为参数，<code>useState</code> 内部<strong>只在组件挂载时执行一次这个函数</strong>，此后组件更新时不会再执行。</p><p>于是刚才的斐波那契初始值就可以这样写：<code>useState(() =&gt; fibonacci(40))</code>  。</p><p>有意思的是，state更新函数，即 <code>setShowAdd</code> 也可以传函数作为参数。一般情况下，是调用state更新函数后组件会更新，而不是反过来。所以state更新函数的调用频率没那么高，传函数参数也并不是为了优化性能。</p><p>这里先给一个背景，调用state更新函数后，组件的更新是<strong>异步</strong>的，不会马上执行；在React 18里，更是为更新state加入了<strong>自动批处理</strong>功能，多个state更新函数调用会被合并到一次重新渲染中。</p><p>这个功能从框架上就保证了state变化触发渲染时的性能，但也带来一个问题，只有在下次渲染时state变量才会更新为最新值，如果希望每次更新state时都要基于当前state值做计算，那么这个计算的基准值有可能已经过时了，如：</p><pre><code class="language-javascript">setShowAdd(!showAdd);
setTodoList([...todoList, aNewTodoItem]);
</code></pre><p>这时函数参数的作用就体现出来了，只要改为下面的方式，就可以保证<strong>更新函数使用最新的state来计算新state值</strong>：</p><pre><code class="language-javascript">setShowAdd(prevState =&gt; !prevState);
setTodoList(prevState =&gt; {
  return [...prevState, aNewTodoItem];
});
</code></pre><p><code>useState</code> 是React最常用的Hook，理解这个Hook对理解其他Hooks很有帮助。</p><h3>useReducer</h3><p>这个小节的标题是“状态Hooks”，之所以有个“s”，是因为 <code>useState</code> 还有一个马甲 <code>useReducer</code> ，如果用 <code>useReducer</code> 来改写上面的 <code>useState</code> ，可以写成这样：</p><pre><code class="language-javascript">function reducer(state, action) {
&nbsp; switch (action.type) {
&nbsp; &nbsp; case 'show':
&nbsp; &nbsp; &nbsp; return true;
&nbsp; &nbsp; case 'hide':
    default:
&nbsp; &nbsp; &nbsp; return false;
&nbsp; }
}

function App() {
&nbsp; const [showAdd, dispatch] = useReducer(reducer, false);
  // ...省略
  dispatch({ type: 'show' });
</code></pre><p>这么写代码好像变多了？这是因为 <code>useReducer</code> 比起 <code>useState</code> 增加了额外的抽象，引入了<code>dispatch</code> 、<code>action</code> 、<code>reducer</code> 概念。这与著名应用状态管理框架Redux基本是对应的。</p><p>说到马甲，其实 <code>useState</code> 底层就是基于 <code>useReducer</code> 实现的，<code>useState</code> 才是马甲。<code>useReducer</code> 适用于抽象封装复杂逻辑，对于现在的 <code>oh-my-kanban</code> 项目是没必要的。</p><p>我们在后面项目篇的课程中会设计更复杂的state，那时就轮到 <code>useReducer</code> 施展拳脚了，届时我们会详细讲这个Hook。</p><h3>更新state的自动批处理</h3><p>前面提到更新state的批处理，为什么需要批量更新state呢？我们先回顾一下 <code>oh-my-kanban</code> 中，添加新卡片按回车键后发生的事情。</p><p>可以看到，在事件处理函数中先后更新了 <code>todoList</code> 和 <code>showAdd</code> 两个state值：</p><pre><code class="language-javascript">function App() {
&nbsp; const [showAdd, setShowAdd] = useState(false);
&nbsp; const [todoList, setTodoList] = useState([/*省略*/]);
  // ...省略
&nbsp; const handleSubmit = (title) =&gt; {
&nbsp; &nbsp; setTodoList(currentTodoList =&gt; [
&nbsp; &nbsp; &nbsp; { title, status: new Date().toString() },
&nbsp; &nbsp; &nbsp; ...currentTodoList
&nbsp; &nbsp; ]);
&nbsp; &nbsp; setShowAdd(false);
&nbsp; };
&nbsp; // ...省略
&nbsp; return (
&nbsp; &nbsp; &lt;div className="App"&gt;
&nbsp; &nbsp; &nbsp; {/*省略*/}
&nbsp; &nbsp; &nbsp; {showAdd &amp;&amp; &lt;KanbanNewCard onSubmit={handleSubmit} /&gt;}
      {/*省略*/}
    &lt;/div&gt;
  );
}
</code></pre><p>组件内的state被更新了，组件就会重新渲染。那么接连更新两个state，组件会重新渲染几次呢？答案是，在上面的代码中，<strong>组件只会重新渲染一次</strong>，而且这次渲染使用了两个state分别的最新值。这就是React<strong>对多个state更新的自动批处理</strong>。</p><p>我们可以想象一下，假设没有批处理功能的话，这两个state更新会触发两次间隔非常近的重新渲染，那前面的这次重新渲染对于用户来说，很有可能是一闪而过的，既没有产生实际交互，也没有业务意义。在此基础上，如果再加上前面这次渲染的成本比较高，那就更是一种浪费了。</p><p>所以可以说，state更新的自动批处理是React确保组件基础性能的重要功能。</p><p>然而需要注意的是，自动批处理功能在React 18版本以前，只在React事件处理函数中生效。如果state更新语句所在的区域稍有不同，比如将两个state更新写在异步请求的回调函数中，自动批处理就失效了。</p><p>用下面的代码举个例子。在点击搜索按钮后，会向服务器端发起搜索请求，当返回结果时，需要先后更新两个state：</p><pre><code class="language-javascript">const Search = () =&gt; {
  const [province, setProvince] = useState(null);
  const [cities, setCities] = useState([]);
  const handleSearchClick = () =&gt; {
    // 模拟调用服务器端接口搜索"吉林"
    setTimeout(() =&gt; {
      setProvince('吉林');
      setCities(['长春', '吉林']);
    }, 1000);
  };
  return (
    &lt;&gt;
      &lt;button onClick={handleSearchClick}&gt;搜索&lt;/button&gt;
      &lt;ul&gt;
        &lt;li&gt;{province}&lt;ul&gt;
          {cities.map(city =&gt; (
            &lt;li&gt;{city}&lt;/li&gt;
          ))}
        &lt;/ul&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</code></pre><p>看起来写法与 <code>oh-my-kanban</code> 的 <code>handleSubmit</code> 区别不是很大，但在React 18以前的版本中，这两个state更新会触发两次重新渲染。</p><p>而从React 18版本起，无论是在事件处理函数、异步回调，还是 <code>setTimeout</code> 里的多个state更新，默认都会被自动批处理，只触发一次重新渲染。</p><h2>在组件内使用可变值：useRef</h2><p>前面讲到更新state值时，需要使用state更新函数。你也许会好奇，既然 <code>useState</code> 返回了state变量，直接给state变量赋值不行吗？</p><p>请你做个小实验吧，在 <code>App</code> 组件函数内，修改 <code>handleAdd</code> 函数：</p><p><img src="https://static001.geekbang.org/resource/image/77/72/77d9a09a270a1c760eb3b4186accbc72.png?wh=1308x322" alt="图片"></p><p>点击添加新卡片按钮，浏览器马上就报错：</p><pre><code class="language-diff">Uncaught TypeError: invalid assignment to const 'showAdd'
&nbsp; &nbsp; handleAdd App.js:204
</code></pre><p>这正如在第6节课提到的：props 和 state 都是不可变的（Immutable）。</p><p>那么，如果需要在React组件中使用可变值该怎么办？答案是，我们可以使用 <code>useRef</code> 这个Hook。下面我们结合一个典型用例，也就是在React组件中访问真实DOM元素，来介绍 <code>useRef</code> 的用法。</p><p>请你为 <code>oh-my-kanban</code> 加入一个提升用户体验的小功能，当打开“添加新卡片”卡片时，自动将其中的文本输入框设置为页面焦点。该功能需求和以下代码来自于第3节课一位名为“<strong>coder</strong>”的学员留言，在此表示感谢：</p><p><img src="https://static001.geekbang.org/resource/image/05/fb/05f10984b663041698aa1fc6a51034fb.png?wh=1360x1126" alt="图片"></p><p>在浏览器内可以看到，上面的代码实现了我们期待的交互，效果展示如下：</p><p><img src="https://static001.geekbang.org/resource/image/91/58/91cf7a290bffe5951b0d18d03db93d58.gif?wh=400x290" alt="图片"></p><p>上面的代码包含了三个React特性，<code>useRef</code>  Hook、HTML元素的 <code>ref</code> 属性，以及 <code>useEffect</code>  Hook。先说 <code>useRef</code> ：</p><pre><code class="language-javascript">const Component = () =&gt; {
  const myRef = useRef(null);
  //&nbsp; &nbsp; -----&nbsp;       &nbsp; ----
  //&nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ^
  //&nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|
  //&nbsp;  可变ref对象&nbsp; &nbsp; &nbsp;可变ref对象current属性初始值

  // 读取可变值
  const value = myRef.current;
  // 更新可变值
  myRef.current = newValue;

  return (&lt;div&gt;&lt;/div&gt;);
};
</code></pre><p>调用 <code>useRef</code> 会返回一个可变ref对象，而且会保证组件每次重新渲染过程中，同一个 <code>useRef</code> Hook返回的可变ref对象都是同一个对象。</p><p>可变ref对象有一个可供读写的 <code>current</code> 属性，组件重新渲染本身不会影响 <code>current</code> 属性的值；反过来，变更 <code>current</code> 属性值也不会触发组件的重新渲染。在第12-13节课中，我们会展开介绍可变值的使用场景。</p><p>然后是HTML元素的 <code>ref</code> 属性。这个属性是React特有的，不会传递给真实DOM。当ref属性的值是一个可变ref对象时，组件在挂载阶段，会在HTML元素对应的真实DOM元素创建后，将它赋值给可变ref对象的 <code>current</code> 属性，即 <code>inputElem.current</code>；在组件卸载，真实DOM销毁之前，也会把 <code>current</code> 属性设置为 <code>null</code>。</p><p>再接下来就是 <code>useEffect(func, [])</code> ，这种使用方法会保证 <code>func</code> 只在组件挂载的提交阶段执行一次，接下来的组件更新时不会再执行。</p><p>这三个特性串起来，就让 <code>KanbanNewCard</code> 组件在挂载时，将 <code>&lt;input&gt;</code> 的真实DOM节点赋值给 <code>inputElem.current</code>，然后在处理副作用时从 <code>inputElem.current</code> 拿到这个真实DOM节点，命令式地执行它的 <code>focus()</code> 方法设置焦点。</p><h2>小结</h2><p>这节课我们借助函数式编程领域的纯函数和副作用的概念，通过类比的方式介绍了什么是Hooks，也同时强调了Hooks与函数组件的紧密联系。</p><p>然后我们列举了React 18版本API中提供的基础Hooks和扩展Hooks，并给出了学习建议。在后半段，我们深入学习了 <code>useState</code> 这个Hook，也遇到了React对于多个state更新的自动批处理功能。</p><p>最后，通过为 <code>oh-my-kanban</code> 增加一个小功能，熟悉了 <code>useRef</code> 的一个常见用例。</p><p>下节课我们会继续Hooks的学习，在掌握作为最重要的基础Hooks的 <code>useEffect</code> 同时，也了解React如何处理副作用。然后会介绍主要用于性能优化的 <code>useMemo</code> 和 <code>useCallback</code> ，也会强调所有Hooks共通的使用限制。最后会回答为什么要优先学习函数组件加Hooks，以及学习了Hooks还是否需要学习类组件的问题。</p><p>最后也附上本节课所涉及的项目源代码：<a href="https://gitee.com/evisong/geektime-column-oh-my-kanban/releases/tag/v0.9.0%E3%80%82">https://gitee.com/evisong/geektime-column-oh-my-kanban/releases/tag/v0.9.0。</a></p><h2>思考题</h2><ol>
<li>这节课的学习了 <code>useState</code> ，从表面上看，这不就是一个JS函数吗？其实不然。我想请你做几个实验，观察一下Hook在使用中都会有哪些限制：</li>
</ol><ul>
<li>在函数组件之外的一个普通函数中调用 <code>useState</code>；</li>
<li>在函数组件内部加一个if条件语句，在满足条件时才去调用 <code>useState</code>；</li>
<li>在函数组件内部定义一个函数，在这个函数内部调用 <code>useState</code>，再在函数组件内调用这个函数。</li>
</ul><ol start="2">
<li>这节课末尾也学习了<code>useRef</code> 可以用来保存和读取可变值，貌似很自由的样子，那请你<br>
根据它的特性来推断一下，可以用 <code>useRef</code> 来代替 <code>useState</code> 吗？</li>
</ol><p>欢迎将你的思考和答案放在留言区，我会跟你交流。我们下节课再见！</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>🐑</span>
  </div>
  <div class="_2_QraFYR_0">你好，我是《现代React Web开发实战》的编辑辰洋，这是👇项目的源代码链接，供你学习与参考： https:&#47;&#47;gitee.com&#47;evisong&#47;geektime-column-oh-my-kanban&#47;releases&#47;tag&#47;v0.9.0</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-14 15:32:04</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/c8/04/fed4c1ad.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>若川</span>
  </div>
  <div class="_2_QraFYR_0">1. React官方文档：Hook 规则<br>https:&#47;&#47;zh-hans.reactjs.org&#47;docs&#47;hooks-rules.html<br>1.1 只在最顶层使用 Hook。不要在循环，条件或嵌套函数中调用 Hook。<br>1.2 只在 React 函数中调用 Hook。不要在普通的 JavaScript 函数中调用 Hook。<br><br>因为本质是链表。在各种判断中写 Hook 会导致节点错乱。<br><br>2. useRef 中值变化是不会触发重新渲染。useState 中则是会触发渲染。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，若川，很棒的答案！</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-12 15:19:29</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/2d/ca/7c/98193e9e.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>奕晨</span>
  </div>
  <div class="_2_QraFYR_0">Hook 在使用中都会有哪些限制：<br>1. 在函数组件之外的一个普通函数中调用 useState；<br>    在函数组件之外的普通函数不能调用 useState；<br>2. 在函数组件内部加一个 if 条件语句，在满足条件时才去调用 useState；<br>   不能<br>3. 在函数组件内部定义一个函数，在这个函数内部调用 useState，再在函数组件内调用这个函数。<br>    不能<br>只能在React函数中调用Hook。<br><br><br>可以用 useRef 来代替 useState 吗？<br>不可以，useState会重新渲染，useRef 值发生变化，不会重新渲染。</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2023-01-11 14:04:31</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/19/64/6f2b7b86.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>01</span>
  </div>
  <div class="_2_QraFYR_0">18 批处理依托的 它的调度器。 可中断。  进入commit 阶段 则不可中断。  是否只渲染一次 这个不一定吧</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，01，我赞同你说的。调度器会根据各个state updater的优先级，调整执行顺序，如果这一轮更新不超时，所有队列里的state updater都能执行完，那就一次渲染搞定；如果更新超时，则把未完成的updater留到下次渲染，这就造成了多次渲染的情况（为了保证state结果一致，有时还需要把上一次渲染中已经执行过的高优先级updater再重复执行一遍）。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-20 23:41:01</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/23/93/23/6b6feb42.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>__Initial</span>
  </div>
  <div class="_2_QraFYR_0">我想问一下：在state自动批处理时，为什么使用函数参数就可以保证更新函数使用最新的state</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，__Initial，在React 18的Fiber协调引擎中，state的更新会被加入到一个名为updateQueue的单向链表中，当顺序执行更新时，如果当前更新就是一个state值，则记录这个值为newState，执行入下一个更新；如果当前更新是一个函数，则把上一个更新时记录的newState值传给函数作为参数，更新函数执行的结果会覆盖newState值，然后继续执行下一个更新。<br><br>如果你感兴趣可以读一下这部分的React源码： https:&#47;&#47;github.com&#47;facebook&#47;react&#47;blob&#47;v18.2.0&#47;packages&#47;react-reconciler&#47;src&#47;ReactFiberClassUpdateQueue.old.js#L573-L580</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-19 12:04:59</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/4f/39/791d0f5e.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>学习前端-react</span>
  </div>
  <div class="_2_QraFYR_0">隔了好久，回答第二个问题。<br>useRef 的使用方式是用用会存放一个最新的值即 current，每次修改也不会触发当前组件的render，这个应该就区别于 useState 了，因为setState 会触发当前组件的render。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，学习前端-react，赞，很棒的答案。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-17 15:51:08</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/dCfVz7wIUT4fM7zQO3gIwXo3BGodP5FJuCdMxobZ5dXpzBeTXiaB3icoFqj22EbIGCu1xxd1FLo9xic0a2pGnunibg/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>风太大太大</span>
  </div>
  <div class="_2_QraFYR_0">1. 函数组件之外的一个普通函数中调用 useState 不会生效<br>2. 函数组件内部加一个 if 条件语句，在满足条件时才去调用 useState 不会生效。<br>3. 在这个函数内部调用 useState，再在函数组件内调用这个函数。  useState 不会生效<br></div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，风太大太大，很棒的答案！正如你所回答的，这些就是第10讲会讲到的React Hooks的使用规则。<br><br>另外在开发模式下，当开发者违反了使用规则时，React的Lint规则会提示错误，同时编译工具也会报错，如：<br><br>  Compiled with problems:<br>  ERROR<br>  <br>  src&#47;KanbanNewCard.js<br>    Line 17:15:  React Hook &quot;useEffect&quot; is called conditionally. React Hooks must be called in the exact same order in every component render  react-hooks&#47;rules-of-hooks<br><br>这是很好的开发者体验。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-16 18:20:22</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/17/a8/1e/4ec85e24.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>joel</span>
  </div>
  <div class="_2_QraFYR_0">useRef 来代替 useState 吗?<br>不能，这两个是不同的使用场景，usestate 是可以出发react 的协调过程，useref 不能</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，joel，很棒的答案。更具体来说，调用 useState返回的state更新函数会触发React的协调过程，而为useRef返回的ref.current赋值并不会。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-15 11:37:35</div>
  </div>
</div>
</div>
</li>
</ul>