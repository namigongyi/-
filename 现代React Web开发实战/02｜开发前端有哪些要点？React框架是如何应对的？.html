<audio title="02｜开发前端有哪些要点？React框架是如何应对的？" src="https://static001.geekbang.org/resource/audio/c3/d2/c30b2d3063a939a0c5c26e889eb243d2.mp3" controls="controls"></audio> 
<p>你好，我是宋一玮，欢迎回到React组件的学习。</p><p>在上节课，我们简单回顾了一下前端开发的历史，指出前端开发领域一直在积累特有的领域知识；提出了GUI图形用户界面也是一种接口，跟后端API开发类似，前端“接口”也有自己的设计准则。然后把本世纪初的Java Web技术当作参照物，列举了前端开发领域的变与不变。希望能帮助开发者坚定持续学习的信心。</p><p>再看现状，现代前端框架有很多，前端项目的技术选型令人头疼。这时前端开发者就希望能有一些方法帮助自己做出选择，不仅是为项目选择，也为了确定自己的学习目标而选择。</p><p>React框架在诸多前端技术排行榜上均位列第一，其生态也是最丰富最活跃的。你可能会好奇：</p><ul>
<li>React框架凭什么这么火？</li>
<li>是不是因为React火，所以我才要学它？</li>
<li>是不是因为React火，每个项目都无脑选它就对了？</li>
</ul><p>在这节课，让我们回归到前端开发的本源，即模版、数据建模、交互、数据传输等等这些要点。我认为正是React在这些要点上具有优秀的设计、实践或生态，才造就了它今天的地位。</p><p>当你理解这些要点，再结合具体前端项目的需要，就可以更有信心地做出是否选型React的判断了。</p><h2>“跳伞”+“跑圈”</h2><p>你看到这个标题想到了什么？《PUBG》还是《和平精英》？啊？你从不打游戏啊，那打扰了。在玩生存类游戏时：</p><!-- [[[read_end]]] --><ul>
<li>高手的流程为开局跳伞、落地跑圈、大吉大利；</li>
<li>菜鸟的流程为开局跳伞、落地成盒、重开一局。</li>
</ul><p>当然，这节课肯定不是要教你打游戏，我只是想用游戏中的概念类比一下前端开发。游戏里选用的策略和装备，基本可以体现出你是不是高手；前端开发中选择怎样的架构和技术选型，很大程度上决定了你能不能“大吉大利”。</p><p>接下来就让我们看看React在全程都起到了什么作用。</p><h2>“跳伞”：从前端架构到实现</h2><p>“跳伞”是一个从高空接近地面的过程，地面的目标由远及近、由粗到细，跳伞玩家也可以控制自己目标落地区域。软件从架构设计到具体实现跟这个过程有很多相似，单是软件架构就可以有所谓<strong>三万英尺视图</strong>（30000-Foot View）、<strong>一千英尺视图</strong>（1000-Foot View）等不同粒度的设计。</p><p>顺便提一下，三万英尺视图本来是商业战略中的概念，后被《97 Things Every Software Architect Should Know》这本合著引入到软件架构设计领域。这门课程专注于前端，所以我们跳过系统架构、软件架构等不那么“前端”的概念。</p><h3>前端应用分类</h3><p>我们先试着从最高空鸟瞰前端应用，目前主流的包含GUI的分布式应用，基本可以分成：</p><ul>
<li>B/S应用
<ul>
<li>浏览器端
<ul>
<li>移动H5应用</li>
<li>桌面Web应用</li>
</ul>
</li>
<li>服务器端</li>
</ul>
</li>
<li>C/S应用
<ul>
<li>客户端
<ul>
<li>移动端App</li>
<li>PC客户端</li>
</ul>
</li>
<li>服务器端</li>
</ul>
</li>
</ul><p>近年来客户端也开始拥抱Web，衍生出基于Webview的Hybrid混合应用。</p><p>它们之间的关联关系如下图：</p><p><img src="https://static001.geekbang.org/resource/image/5f/yy/5f7de8dc615819afbb073da1e85faeyy.jpg?wh=3247x1914" alt=""></p><p>看到这样的地图，结合第一节的内容，你在“跳伞”的第一时间，基本就能确定自己要往哪里跳了。是的，你的目标区域是浏览器端，这也是React框架最擅长的领域。</p><p>我们这门课主要针对浏览器端，特别是桌面浏览器。之所以定位到桌面浏览器，是考虑到相关开发调试工具更加丰富，有利于在实践中学习。课程的绝大部分内容也适用于移动端H5应用。</p><h3>前端逻辑架构</h3><p>当你跳出机舱，下降了三分之一高度时，会看清浏览器端Web应用的一部分结构。这些结构仍在逻辑层面，相对抽象，强调各个模块的层次结构和相互关系，还不涉及到技术实现。这在软件架构设计中一般被称为<strong>逻辑架构</strong>。</p><p>前端的逻辑架构，设计的重点自然是前端应用。以用户体验较好的SPA单页应用（Single Page Application）为例，下图是一张用于参考的逻辑架构图，注意这张架构图并不是通用的、四海皆准的，我们只是用它作为例子：</p><p><img src="https://static001.geekbang.org/resource/image/c5/34/c5c03914ee9bf36e9f34fe9a2f8b7a34.jpg?wh=4000x2250" alt=""></p><p>在上图中，作为前端的SPA会包含若干业务功能模块，和服务器通信、前端路由、表单处理、错误处理等多种通用功能模块。通过服务器通信模块，前端会请求服务器端接口，获取或修改业务数据。服务器端即后端，一般包含入口的API网关（Gateway）、若干个后端服务，底层是数据库存储。</p><p>在架构图的两侧，展示了部分支持性质的模块。在设计阶段定义的设计系统（Design System）、响应式布局、可访问性等用户体验领域知识会支持整个前端应用的开发。在部署上线阶段，打包编译、CI/CD、自动化测试、运维工具等基础设施，会保证开发者辛辛苦苦开发的应用最终可以为用户所见、被用户使用。在运行时，用户认证（Authentication）、授权（Authorization）、前端监控、配置管理等通用模块可以支撑应用的正常运行。</p><p>你如果仔细观察会发现，这些模块在图上呈现的高度并不一致，与前端应用层也没有完全对齐。请你放心，我在画图上有些强迫症，这里是故意这么画的：</p><ul>
<li>最右边的用户体验领域设计，是纯前端的支持模块，所以高度与前端一致，并在纵向上与前端对齐；</li>
<li>左右两侧的部署上线基础设施和运行时模块，基本同时涵盖了前端后端，所以它们的底边都延长到与后端平齐。</li>
</ul><p>你如果追问为什么后端底边比其他模块更低？纯粹是为了美术上的构图平衡，让图更顺眼些。</p><p>其实在业界实践中，一个相对复杂的前端应用可能会同时包含多个SPA，最终以MPA多页应用（Multi-Page Application）的形式提供给用户。当然，这并不是必须的。</p><h3>前端应用架构</h3><p>别忘了，你还在“跳伞”过程中。经过刚才的观察，你已经搞清了前端应用从逻辑上都有哪些模块。我希望你一边继续下降，一边调整方向对准SPA单页应用区域。</p><p>已经下降了三分之二高度，这时你可以看清SPA内部的一些技术细节了。这些细节更加贴近技术，但还是相对抽象的，不限定技术实现方式。这在软件架构设计中属于<strong>应用架构</strong>。</p><p>下图是典型的MVC（Model-View-Controller）应用架构的变体：</p><p><img src="https://static001.geekbang.org/resource/image/fa/f9/fa5706d7d9e5de02742b3af899568ef9.jpg?wh=3464x2070" alt=""></p><p>一个“纯粹”的MVC架构，视图会触发控制器，控制器修改模型，模型再触发视图更新。常见的MVC变体，包括MVVM（Model-View-ViewModel）、MVP（Model-View-Presenter）、MVI（Model-View-Intent）。其中MVI架构最接近React社区里提倡的单向数据流。</p><p>既然是“跳伞”，那可别忘了开伞，现在是时候了。</p><h2>“跑圈”：前端技术选型与React</h2><p>好了，“跳伞”的你顺利落地了。现在开始“跑圈”。跑圈是指在有限的地面范围有目的地持续移动，造访多个目标地点、获取装备、采取各类行动；之后随着时间的推进，地面范围会逐渐缩小，你的行动也将更具挑战，之前实现的目标和积累的装备会成为你的助力，最终获胜。</p><p>软件开发中的<strong>技术选型</strong>和实现与这一过程异曲同工。软件架构要落地，其中一个重要环节就是技术选型。在前端领域，技术选型尤为重要。一般而言，前端开发交付的产品最终会<strong>运行在一个受限环境中</strong>，如浏览器、智能手机平台、Webview等，反过来就会要求<strong>前端框架也要迎合运行环境的特性</strong>，否则它有可能帮倒忙。</p><p>举个例子，浏览器里支持的脚本语言是JavaScript，但你在技术选型时第一时间选择了Go语言，那将很难开发浏览器端的交互逻辑（啊？你说Go代码编译成WebAssembly，那没事了）。</p><p>先根据“跳伞”时看到的各种模块，确定一下需要选型的前端技术点：</p><ol>
<li>开发语言</li>
<li>MVC或类MVC框架</li>
<li>服务器通信</li>
<li>表单处理</li>
<li>错误处理</li>
<li>前端路由</li>
<li>打包编译工具</li>
<li>自动化测试框架</li>
</ol><p>暂时只列这么多。实践中根据具体应用需求不同，还会有很多其他技术点需要考虑。</p><p>下面请你跟随我，结合以上选型技术点，<strong>看React框架如何满足前端应用开发的需要。</strong></p><h3>开发语言</h3><p>无论框架怎么选，先得选好开发语言。浏览器原生支持的语言包括：文档语言<strong>HTML</strong>、样式语言<strong>CSS</strong>和脚本语言<strong>JavaScript</strong>。2019年底<strong>WebAssembly</strong>正式进入W3C标准，成为浏览器的第四种原生支持语言，不过这门课程不会涉及WebAssembly。</p><p>除了这些原生支持的语言，开发者还可以使用其他语言开发，然后编译成原生语言在浏览器中执行。如JS的超集<strong>TypeScript</strong>，语法与JS相近，支持类型系统，通过编译器编译成浏览器可执行的JS，尤其适合开发大型Web应用。再如<strong>LESS</strong>、<strong>SaSS</strong>，扩展了CSS的语法，更方便模块化，通过编译器可以编译成浏览器可解析的CSS。</p><p>关于JS，还有一个值得提的点，在浏览器JS演进过程中，厂商和技术社区合作推出了标准化的<strong>ECMAScript</strong>（简称ES），从ES6即ES2015开始，每年ES会推出一个包含少量新语法或新接口的新版本。</p><p>其中ES2015包含的新特性是最多的，随后ES2017的 <code>Async</code>/<code>Await</code> 、ES2018的对象展开语法（<code>...</code>）、ES2020的可选链操作符（<code>?.</code>）都是改变JS开发者编程习惯的重要特性。然而并不是所有浏览器的所有版本都支持最新的ECMAScript。</p><p>为了兼容用户的老浏览器，但又能充分利用新语法带来的好处，可以用Babel这样的编译器将高版本的ES代码转译成更多浏览器支持的低版本，如为了（不得不）支持已经退出历史舞台的IE11，将ES2020的代码转译成ES5。</p><p>这门课程中的样例代码将以ES2020编写。</p><h3>React对应技术点</h3><p>React框架是Meta公司前身Facebook（下称FB）于2013年开源的，声明式、组件化的前端开发框架。</p><p>首先从开发语言看，React支持ES2015以上的版本。虽然也支持ES5，但并不推荐，如果必须要支持老浏览器，那就利用Babel转译吧。同时，React对TypeScript也有很好的支持，提供了完整的类型定义。所以打算用React时，你不用担心语言支持的问题。</p><p>然后，我们不妨把React直接拉进我们的技术选型里，看看React涵盖了哪些技术点。</p><p><strong>第一，<strong><strong>MVC或类MVC框架</strong></strong>。</strong></p><p>React为视图层带来了声明式的<strong>JSX语法</strong>，这种语法是模版的同时又是JS语言本身，易学性、灵活性和性能远超其他模版引擎。</p><p>在视图之外，React设计了一套<strong>单向数据流</strong>机制进行<strong>应用状态管理</strong>。从视图事件触发状态变更，状态变更的结果汇总在一起，通过不可变数据传递给关心这些数据的视图，视图根据传入的数据决定是否重新渲染。</p><p>开发者将视图和相关逻辑声明成一个个<strong>React组件</strong>，React底层实现了一套<strong>虚拟DOM模型</strong>，它比浏览器DOM更为轻量，React靠比对新旧两个虚拟DOM来实现低成本的渲染。</p><p>这里提到的JSX语法、React组件、虚拟DOM、单向数据流，在后续课程中会一一讲解。</p><p>说句题外话，虚拟DOM作为一种抽象，并不与浏览器直接绑定，理论上可以用于其他平台。于是2015年FB开源了React Native框架，开发者们可以用JS语言，加上与React基本相同的API开发iOS和Android的原生应用。</p><p>与Hybrid应用不同，React Native的JSX会被渲染成目标平台的原生组件，进而提高性能、提升体验，这在当时也给React挣足了面子。但不像React，React Native在后来发展中经历过一些波折，被Google推出的跨端框架Flutter迎头赶上。</p><p><strong>第二，<strong><strong>表单处理</strong></strong>。</strong></p><p>React框架本身并没有提供高度抽象的表单处理组件或者接口。但在React开发者可以将HTML表单元素声明为<strong>受控组件</strong>（Controlled Components），并基于受控组件的状态数据进行表单处理。</p><p><strong>第三，<strong><strong>错误处理</strong></strong>。</strong></p><p>React没有内建处理全局错误的机制，但提供了<strong>错误边界</strong>（Error Boundaries）API，可以在组件树中实现类似<code>try...catch</code> 的功能。</p><p>受控组件、错误边界在后续的课程中会涉及到。</p><h3>React生态</h3><p>你可能会吐槽，React的功能怎么这么少？隔壁Angular可是内置了服务器通信模块和路由模块啊！</p><p>我个人认为所谓的“功能少”反而是React流行的重要原因之一。一个大而全的框架难免会落入一个窘境：学起来更累，用起来更重，定制起来也更受限。</p><p>React做好了属于自己卖点的部分：声明式、组件化、单向数据流，以及后来的Hooks，其他领域则留给第三方。用React的人越多，为React开发的第三方开源库越多；React生态越丰富，用React的人越多。这就形成了<strong>React的马太效应</strong>。</p><p>列举一些React生态：</p><ul>
<li>类MVC框架：早期的React侧重于视图，并没有内置 <code>dispatch</code> 和 <code>reducer</code> 相关的接口，但开源社区为React设计的应用状态管理框架如雨后春笋，百家争鸣，如FB的Flux、开源的Redux、MobX等等；</li>
<li>服务器通信：浏览器标准的<code>fetch</code> API，以及更强的React Query框架；</li>
<li>表单处理：Formik框架、React Hook Form框架；</li>
<li>前端路由：事实标准的 <code>react-router</code> 框架；</li>
<li>组件样式：诸多CSS-in-JS框架，如 <code>emotion</code> ；</li>
<li>打包编译工具：Webpack、Babel，以及包含了前者的Create-React-App脚手架；</li>
<li>自动化测试框架：Jest、React Testing Library。</li>
</ul><p>此外还有大批高质量的可复用组件库，如AntD、Material-UI等。这些第三方框架和工具，为React补足了开发现代Web应用缺少的功能。有些组合固定出现，以至于被开发者戏称为“React全家桶”。</p><h2>小结</h2><p>这节课我们借用“跳伞”+“跑圈”的比喻，将这门课程的范围设定在桌面Web应用，从架构层面分析了前端开发的组成部分，包括逻辑架构的SPA、业务功能模块、通用功能模块和应用架构的类MVC模式。</p><p>然后聊了技术选型阶段面对的技术点，将ES2020指定为这门课程的开发语言，也简要介绍了React框架本身和React生态的分工。</p><p>下节课我们会快速进入实践环节，请你跟着我写一个简单的React应用。</p><h2>思考与互动</h2><p>“跳伞”过程中你看到了前端逻辑架构和应用架构，里面定义的不少模块在各类前端框架中都很常见。可否请你选择一个你熟悉或者完全不熟悉的、React以外的前端框架，对照着这个框架的文档，看看框架都涵盖了哪些模块？</p><p>欢迎把你的思考和想法分享在留言区，也欢迎把课程分享给你的朋友或同事，我们下节课见！</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/3yrFKWqFztYZWPHlZIicRfMWbsuLS5WO3tH8g0o3ouic8PHrvTyWyuXaBBA8tiapgcaicibfFpgYbB7VEibywia41TOCQ/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>chen</span>
  </div>
  <div class="_2_QraFYR_0">一直不太明白react的单向数据流和vue的双向绑定有啥区别</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-11-03 22:10:34</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/10/3a/e3/f368fb4a.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Angry阳。</span>
  </div>
  <div class="_2_QraFYR_0">学习了</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-11 18:35:05</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/a0/59/86073794.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Hello,Tomrrow</span>
  </div>
  <div class="_2_QraFYR_0">第二天，打卡</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-08-29 09:25:44</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/2a/fa/90/cfba2d42.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>.</span>
  </div>
  <div class="_2_QraFYR_0">几乎没有这些框架设计的理念， 平时看代码都是逐行逐句看的。 </div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，. ，这也是很棒的学习方法，了解框架思想和阅读框架源码两者不冲突，如果能双管齐下效果更好。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-08-27 17:05:37</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9cTNT17YPxDYTD0dCcG8GF47fYK5xTn9rHRXtXwVicTlhQbueZSibE4yBZb5ZHjQAuB89lrticAHnA/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Geek_fujinshuai</span>
  </div>
  <div class="_2_QraFYR_0">借用网络经典书籍名， 自顶向下学习方法！</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，Geek_fujinshuai，你说得对，自顶向下是很重要的学习方法。在后面的课程中，在自顶向下的基础上，也会有诸如组件代码复用这样一些自下而上、归纳总结的内容。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-08-23 21:47:05</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/17/9b/52/cb97162e.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Sarai李</span>
  </div>
  <div class="_2_QraFYR_0">感谢大佬的呈现，这样“由高到低”的视野让小白也有了感谢认识！打算直接跟着这个课程快速入门！</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-12-27 09:43:22</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Geek_9373fc</span>
  </div>
  <div class="_2_QraFYR_0">老师你好，请问为什么jsx是声明式？声明式和命令式的区别是什么？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，Geek_9373fc，这是个好问题，声明式和命令式的区别在下周二将更新的《04 | JSX：该怎样理解这种声明式语法糖？》中有详细讲解。先剧透一下：声明式是“描述开发者期待的视图状态”。敬请期待。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-08-25 21:44:49</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/20/83/f0/9f063379.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>我听着呢</span>
  </div>
  <div class="_2_QraFYR_0">老师课程之后会讲工程化方面的内容吗</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，我听着呢，第二章最后一节课，以及第三章中多节课都会讲到React项目的工程化。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-08-23 16:45:37</div>
  </div>
</div>
</div>
</li>
</ul>