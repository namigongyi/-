<audio title="加餐02｜留言区心愿单：Fiber协调引擎" src="https://static001.geekbang.org/resource/audio/f1/00/f14663b18dca36a8f52f8b4e69e43300.mp3" controls="controls"></audio> 
<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>之前提到过，我们会在专栏的留言区选取一些具有代表性的问题，放到加餐里统一讲解。</p><p>上次的加餐01我们介绍了“真·子组件”，以及JSX语法糖在React 17版本以后发生的变化。这节加餐我们有且只有一个主题，就是目前留言区呼声最高的，Fiber协调引擎。</p><p>首先还是要说明一下，在React 18.2.0中，Fiber的源代码有3万多行（以 <code>wc -l packages/react-reconciler/src/*[^new].js</code> 命令统计），要想搞清它的每一行代码都是干什么的，一节加餐是远远不够的。</p><p>这节加餐会从原理入手，介绍Fiber内的部分重要模型和一些关键流程，并尽量跟前面课程中学到的React各种概念串联起来，这包括React元素、渲染过程、虚拟DOM、生命周期、Hooks。不求面面俱到，为的是帮助你加深对React框架的理解。</p><p>另外请注意，Fiber协调引擎是React的内部实现，无论是否学习它，都不会影响你对React框架的使用。</p><h2>什么是Fiber协调引擎？</h2><p>正如第6节课讲到的：</p><blockquote>
<p>React组件会渲染出一棵元素树……每次有props、state等数据变动时，组件会渲染出新的元素树，React框架会与之前的树做Diffing对比，将元素的变动最终体现在浏览器页面的DOM中。这一过程就称为<strong>协调（Reconciliation）</strong>。</p>
<blockquote>
<p>在React的早期版本，协调是一个<strong>同步过程</strong>，这意味着当虚拟DOM足够复杂，或者元素渲染时产生的各种计算足够重，协调过程本身就可能超过16ms，严重的会导致页面卡顿。而从React v16开始，协调从之前的同步改成了<strong>异步过程</strong>，这主要得益于新的<strong>Fiber协调引擎</strong>。</p>
</blockquote>
</blockquote><!-- [[[read_end]]] --><p>Fiber协调引擎做的事情基本上贯穿了React应用的整个生命周期，包括并不限于：</p><ul>
<li>创建各类FiberNode并组建Fiber树；</li>
<li>调度并执行各类工作（Work），如渲染函数组件、挂载或是更新Hooks、实例化或更新类组件等；</li>
<li>比对新旧Fiber，触发DOM变更；</li>
<li>获取context数据；</li>
<li>错误处理；</li>
<li>性能监控。</li>
</ul><p>Fiber协调引擎的源代码集中在 <code>react-reconciler</code> 这个包里，在Github上的地址是： <a href="https://github.com/facebook/react/tree/v18.2.0/packages/react-reconciler">https://github.com/facebook/react/tree/v18.2.0/packages/react-reconciler</a></p><h2>Fiber中的重要概念和模型</h2><p>在协调过程中存在着各种动作，如调用生命周期方法或Hooks，这在Fiber协调引擎中被称作是<strong>工作</strong>（Work）。Fiber中最基本的模型是<strong>FiberNode，用于描述一个组件需要做<strong><strong>的</strong></strong>或者已完成的工作，每个组件可能对应一个或多个FiberNode</strong>。这与一个组件渲染可能会产生一个或多个React元素是一致的。</p><p>实际上，每个 <code>FiberNode</code> 的数据都来自于元素树中的一个元素，元素与 <code>FiberNode</code> 是一一对应的。与元素树不同的是，元素树每次渲染都会被重建，而 <code>FiberNode</code> 会被复用，<code>FiberNode</code> 的属性会被更新。</p><p>下面是 <code>FiberNode</code> 的数据结构，为了方便理解，我把关键的属性进行了分组，并省略了一些我认为不太关键的属性：</p><pre><code class="language-typescript">type Fiber = {
  // ---- Fiber类型 ----

  /** 工作类型，枚举值包括：函数组件、类组件、HTML元素、Fragment等 */
  tag: WorkTag,
  /** 就是那个子元素列表用的key属性 */
  key: null | string,
  /** 对应React元素ReactElmement.type属性 */
  elementType: any,
  /** 函数组件对应的函数或类组件对应的类 */
  type: any,

  // ---- Fiber Tree树形结构 ----

  /** 指向父FiberNode的指针 */
  return: Fiber | null,
  /** 指向子FiberNode的指针 */
  child: Fiber | null,
  /** 指向平级FiberNode的指针 */
  sibling: Fiber | null,
  
  // ---- Fiber数据 ----

  /** 经本次渲染更新的props值 */  
  pendingProps: any,
  /** 上一次渲染的props值 */
  memoizedProps: any,
  /** 上一次渲染的state值，或是本次更新中的state值 */
  memoizedState: any,
  /** 各种state更新、回调、副作用回调和DOM更新的队列 */
  updateQueue: mixed,
  /** 为类组件保存对实例对象的引用，或为HTML元素保存对真实DOM的引用 */
  stateNode: any,

  // ---- Effect副作用 ----

  /** 副作用种类的位域，可同时标记多种副作用，如Placement、Update、Callback等 */
  flags: Flags,
  /** 指向下一个具有副作用的Fiber的引用，在React 18中貌似已被弃用 */
  nextEffect: Fiber | null,

  // ---- 异步性/并发性 ----
  
  /** 当前Fiber与成对的进行中Fiber的双向引用 */
  alternate: Fiber | null,
  /** 标记Lane车道模型中车道的位域，表示调度的优先级 */
  lanes: Lanes
};
</code></pre><p>其他需要关注的，还有与Hooks相关的模型，这包括了 <code>Hook</code> 和 <code>Effect</code> ：</p><pre><code class="language-typescript">type Hook = {
&nbsp; memoizedState: any,
&nbsp; baseState: any,
&nbsp; baseQueue: Update&lt;any, any&gt; | null,
&nbsp; queue: any,
&nbsp; next: Hook | null,
};

type Effect = {
&nbsp; tag: HookFlags,
&nbsp; create: () =&gt; (() =&gt; void) | void,
&nbsp; destroy: (() =&gt; void) | void,
&nbsp; deps: Array | null,
&nbsp; next: Effect,
};
</code></pre><p>此外，还有 <code>Dispatcher</code>。基本每个Hook都有 <code>mount</code> 和 <code>update</code> 两个 <code>dispatcher</code>，如 <code>useEffect</code> 有 <code>mountEffect</code> 和 <code>updateEffect</code> ；少数Hooks还有额外的<code>rerender</code> 的 <code>dispatcher</code>，如 <code>useState</code>有<code>rerenderState</code> 。</p><h2>协调过程是怎样的？</h2><p>当第一次渲染，React元素树被创建出来后，Fiber协调引擎会从 <code>HostRoot</code> 这个特殊的元素开始，遍历元素树，创建对应的 <code>FiberNode</code> 。</p><p><code>FiberNode</code> 与 <code>FiberNode</code> 之间，并没有按照传统的parent-children方式建立树形结构。而是在父节点和它的第一个子节点间，利用<code>child</code> 和 <code>return</code> 属性建立了双向链表。节点与它的平级节点间，利用 <code>sibling</code> 属性建立了单向链表，同时平级节点的 <code>return</code> 属性，也都被设置成和单向链表起点的节点 <code>return</code> 一样的值引用。</p><p>如图所示：</p><p><img src="https://static001.geekbang.org/resource/image/c6/60/c6d3d4806b9a80344a4431fc8245a460.jpg?wh=1142x670" alt=""></p><p>这样做的好处是，可以在协调引擎进行工作的过程中，<strong>避免递归遍历Fiber树，而仅仅用两层循环来完成深度优先遍历</strong><strong>，</strong>这个用于遍历Fiber树的循环被称作workLoop。</p><p>以下是workLoop的示意代码，为了便于理解，我对源码中的 <code>performUnitOfWork</code> 、 <code>beginWork</code>、<code>completeUnitOfWork</code>、<code>completeWork</code> 做了合并和简化，就是里面的 <code>workWork</code> （WARCRAFT梗）：</p><pre><code class="language-javascript">let workInProgress;

function workLoop() {
  while (workInProgress &amp;&amp; !shouldYield()) {
    const child = workWork(workInProgress);
    if (child) {
      workInProgress = child;
      continue;
    }
    
    let completedWork = workInProgress;
    do {
      if (completedWork.sibling) {
        workInProgress = completedWork.sibling;
        break;
      }
      completedWork = completedWork.return;
    } while (completedWork);
  }
}
</code></pre><p>更狠的一点是，这个循环<strong>随时可以跑，随时可以停</strong>。这意味着 <code>workLoop</code> 既可以同步跑，也可以异步跑，当 <code>workLoop</code> 发现进行中的Fiber工作耗时过长时，可以根据一个 <code>shouldYield()</code> 标记决定是否暂停工作，释放计算资源给更紧急的任务，等完成后再恢复工作。</p><p>当组件内更新state或有context更新时，React会进入渲染阶段（Render Phase）。这一阶段是异步的，Fiber协调引擎会启动<code>workLoop</code> ，从Fiber树的根部开始遍历，快速跳过已处理的节点；对有变化的节点，引擎会为 <code>Current</code><strong>（当前）节点</strong>克隆一个 <code>WorkInProgress</code><strong>（进行中）节点</strong>，将这两个FiberNode的 <code>alternate</code> 属性分别指向对方，并把更新都记录在<code>WorkInProgress</code> 节点上。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/30/d0/303937fc145e64f0242bcd65c2d96bd0.jpg?wh=1142x550" alt=""></p><p>你可以理解成同时存在两棵Fiber树，<strong>一棵 <code>Current</code> 树，对应着目前已经渲染到页面上的内容</strong>；<strong>另一棵是 <code>WorkInProgress</code> 树，记录着即将发生的修改</strong>。</p><p>函数组件的Hooks也是在渲染阶段执行的。除了<code>useContext</code> ，Hooks在挂载后，都会形成一个由 <code>Hook.next</code> 属性连接的单向链表，而这个链表会挂在 <code>FiberNode.memoizedState</code> 属性上。</p><p>在此基础上，<code>useEffect</code> 这样会产生副作用的Hooks，会额外创建与 <code>Hook</code> 对象一一对应的 <code>Effect</code> 对象，赋值给 <code>Hook.memoizedState</code> 属性。此外，也会在 <code>FiberNode.updateQueue</code> 属性上，维护一个由 <code>Effect.next</code> 属性连接的单向链表，并把这个 <code>Effect</code> 对象加入到链表末尾。</p><p>当Fiber树所有节点都完成工作后，<code>WorkInProgress</code> 节点会被改称为 <code>FinishedWork</code><strong>（已完成）节点</strong>，<code>WorkInProgress</code> 树也会被改称为 <code>FinishedWork</code><strong>树</strong>。这时React会进入提交阶段（Commit Phase），这一阶段主要是同步执行的。Fiber协调引擎会把<code>FinishedWork</code> 节点上记录的所有修改，按一定顺序提交并体现在页面上。</p><p>提交阶段又分成如下3个先后同步执行的子阶段：</p><ul>
<li>
<p><strong>变更前（Before Mutation）子阶段</strong>。这个子阶段会调用类组件的getSnapshotBeforeUpdate方法。</p>
</li>
<li>
<p><strong>变更（Mutation）子阶段</strong>。这个子阶段会更新真实DOM树。</p>
<ul>
<li>递归提交与删除相关的副作用，包括移除ref、移除真实DOM、执行类组件的 <code>componentWillUnmount</code>  。</li>
<li>递归提交添加、重新排序真实DOM等副作用。</li>
<li>依次执行 <code>FiberNode</code> 上 <code>useLayoutEffect</code> 的清除函数。</li>
<li>引擎用 <code>FinishedWork</code> 树替换 <code>Current</code> 树，供下次渲染阶段使用。</li>
</ul>
</li>
<li>
<p><strong>布局（Layout）子阶段</strong>。这个子阶段真实DOM树已经完成了变更，会调用 <code>useLayoutEffect</code> 的副作用回调函数，和类组件的 <code>componentDidMount</code> 方法。</p>
</li>
</ul><p>在提交阶段中，引擎还会多次异步或同步调用 <code>flushPassiveEffects()</code> 。这个函数会先后两轮按深度优先遍历Fiber树上每个节点：</p><ul>
<li>第一轮：如果节点的 <code>updateQueue</code> 链表中有待执行的、由 <code>useEffect</code> 定义的副作用，则顺序执行它们的<strong>清除函数</strong>；</li>
<li>第二轮：如果节点的 <code>updateQueue</code> 链表中有待执行的、由 <code>useEffect</code> 定义的副作用，则顺序执行它们的<strong>副作用回调函数</strong>，并保存清除函数，供下一轮提交阶段执行。</li>
</ul><p>这个<code>flushPassiveEffects()</code> 函数真正的执行时机，是在上述提交阶段的三个同步子阶段之后，下一次渲染阶段之前。引擎会保证在下一次渲染之前，执行完所有待执行的副作用。</p><p>你也许会好奇，协调引擎的Diffing算法在哪里？其实从渲染到提交阶段，到处都在利用memoizedProps和memoizedState与新的props、state做比较，以减少不必要的工作，进而提高性能。</p><p>以上学习了Fiber协调引擎的工作流程，再回来看看 <code>oh-my-kanban</code> 的Fiber树，是不是能更进一步理解 <code>oh-my-kanban</code> 的生命周期了？</p><p><img src="https://static001.geekbang.org/resource/image/89/f6/892b4a21cb0a4d59a94a65e247b68af6.jpg?wh=1142x672" alt=""></p><p>好了，Fiber协调引擎我们暂时就讲到这里。</p><p>如果你还有其他想听的话题，或者在课程学习中有什么疑问，欢迎在留言区告诉我。下节课再见！</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/bc/e3/6267bf06.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>乐雨</span>
  </div>
  <div class="_2_QraFYR_0">没有讲到任务优先级和饥饿问题的处理</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，乐雨，感谢你的留言，这篇加餐主要关注了React源码中packages&#47;react-reconciler的内容，确实没有讲到 packages&#47;scheduler，即任务优先级和调度相关的内容。Scheduler也是React内部的重要模块，之后有机会再为大家介绍。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-26 16:48:31</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/17/a8/1e/4ec85e24.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>joel</span>
  </div>
  <div class="_2_QraFYR_0">要是有视频就更好，老师辛苦了</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，joel，只要你有收获我就不辛苦（握手）。最近专栏编辑跟我有讨论过连载完结时的一些策划，里面有可能有视频。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-23 14:56:50</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/e7/20/70a95f94.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>潮汐</span>
  </div>
  <div class="_2_QraFYR_0">这篇加餐结合正文课程第6、8节和文中的图，对渲染、协调有更深的理解。与6、8节正文的图形成互相诠释说明，值得反复对比理解！</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2023-02-19 15:04:42</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/4f/39/791d0f5e.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>学习前端-react</span>
  </div>
  <div class="_2_QraFYR_0">请问：修改state 是生成fiber 并 diffing的过程？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，学习前端-react，从结果来看，你的说法是ok的。<br><br>在reconciler内部，修改state会把更新加入到更新队列里，并标记fiber待更新，在完成高优先级的工作以后，scheduler（另一个包）会从队列中拿出更新工作，放到下一轮render阶段，并做diffing。<br><br>所以整体而言修改state是异步的，这也使得React也有足够空间可以调整工作的优先级，合并多个state修改、做批处理。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-29 00:14:58</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/4f/39/791d0f5e.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>学习前端-react</span>
  </div>
  <div class="_2_QraFYR_0">感谢宋老师的精彩加餐。目前看下来一餐可能不太够，有点囫囵吞枣的感觉。<br></div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，学习前端-react，感谢你的认可。Fiber协调引擎能讲的东西确实很多，这节短短的加餐很难讲全。加餐主要的目的，还是希望能用Fiber协调引擎的基本原理把前面学到的React概念、API串联起来，帮大家更好地掌握React开发。<br><br>加餐心愿单依然开放，欢迎接着提 ：）</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-29 00:14:54</div>
  </div>
</div>
</div>
</li>
</ul>