<audio title="19｜代码复用：如何设计开发自定义Hooks和高阶组件？" src="https://static001.geekbang.org/resource/audio/f7/14/f7be20d6a1d77903fa8bdddbd6000414.mp3" controls="controls"></audio> 
<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>可能你已经发现了，前面第15节课的不可变数据、第16～17节的应用状态管理，还有上节课用TypeScript为React项目引入类型系统，其实都在为我们应对大中型React项目中的复杂数据流打基础。</p><p>大中型React项目复杂的不只是数据流，还有应用逻辑，所以接下来我们就把重点放到应用逻辑上。应用逻辑我们会分为<strong>局部</strong>和<strong>整体</strong>两个部分来学习，这节课我们先来看局部，即组件逻辑。</p><p>组件逻辑越来越复杂怎么办？我曾观察过不少单组件包含数百行、甚至上千行代码的情况。其中有结构清晰、易于维护的模范代码，但更多的还是可以当作负面典型的后进代码，这些组件代码往往存在以下问题：</p><ul>
<li>承担了过多的职责；</li>
<li>业务逻辑和交互逻辑杂糅在一起；</li>
<li>从其他组件中复制粘贴代码。</li>
</ul><p>具体表现为：</p><ul>
<li>传递的props个数过多；</li>
<li>使用 <code>useState</code> 的个数过多；</li>
<li>单个 <code>useEffect</code> 的副作用回调函数行数过多；</li>
<li>……</li>
</ul><p>这些问题大都可以通过抽象的方式改进。那么接下来，我们就来学习如何设计开发自定义Hooks和高阶组件，以达到抽象和代码复用。</p><h2>抽象的目的</h2><p>我们对抽象（Abstraction）并不陌生，前面<a href="https://time.geekbang.org/column/article/574161?">第13节课</a>提到的面向接口编程，就是抽象的一种。MVC架构里M、V、C分别也都是抽象，后端开发中的分层架构，每一层也是抽象。在软件开发中，抽象可以用来降低程序的复杂度，使得开发者可以专注处理少数重要的部分。</p><!-- [[[read_end]]] --><p>我曾观察到一种误区，就是认为“抽象只是为代码复用而做的，不需要复用的话就没必要抽象”，其实不是这样的。为了代码复用确实需要先做抽象，但我们日常开发工作中大部分的抽象其实都不是为了代码复用，而是为了开发出更有效、更易读、更好维护的代码。</p><p>我们稍微回顾一下上一个模块中的 <code>oh-my-kanban</code> 项目，在<a href="https://time.geekbang.org/column/article/553817">第3节课</a>的源码中， <code>src/App.js</code> 文件中只包含了 <code>App</code> 、 <code>KanbanCard</code> 、 <code>KanbanNewCard</code> 三个组件。请你设想一下，假如当时不继续拆分组件，而直接把第二模块中所有的新功能都加到这三个组件里，这三个组件的代码会有多么臃肿？</p><p>所以就有了从<a href="https://time.geekbang.org/column/article/561203">第5节课</a>开始的组件拆分，一直到第12～13的大重构，这些过程其实都是在做抽象。</p><p>组件拆分时抽象出了两个新组件 <code>KanbanBoard</code> 和 <code>KanbanColumn</code> ，但当时这两个新组件只封装了DOM结构和样式。后来的大重构对 <code>App</code> 里的数据和逻辑重新做了抽象，让 <code>App</code> 之外的组件分别封装自己的视图、数据和逻辑，有效降低了开发维护 <code>App</code> 组件时的负担。</p><p>接下来我们来看React应用中两种主要的抽象方式：自定义Hooks和组件组合。</p><h2>自定义Hooks</h2><p>在开发React函数组件时，我们会大量使用Hooks，包括<code>useState</code>、<code>useEffect</code>等。当这些Hooks的组合满足一定业务逻辑或者是交互逻辑时，可以根据需要将它们提取成自定义Hooks。</p><p>自定义Hook首先是一个函数，它的函数名应以<code>use*</code>开头，它内部调用的其他Hooks仍旧需要遵守<a href="https://time.geekbang.org/column/article/566856">第10节课</a>中讲到的，Hooks的使用规则：</p><blockquote>
<p>第一，只能在React的函数组件中调用Hooks。<br>
第二，只能在组件函数的最顶层调用Hooks。</p>
</blockquote><p>也许你会问：“等下，说是要遵守，这不一下子把两条规则都打破了吗？”其实不冲突，主要是以下两个原因：</p><ul>
<li>自定义Hooks只会在React函数组件中执行才有效；</li>
<li>自定义Hooks只是很薄的封装，虽然在运行时的调用栈上会增加一层，但这层并不会在组件与被封装的Hooks之间增加额外的循环、条件分支。</li>
</ul><p>来看一个典型的业务型自定义Hook。</p><p>以下代码是一个书籍列表组件，会从服务器端读取特定类别下的书籍列表数据（注意 <code>React.StrictMode</code> 会重复触发副作用回调函数，为了简化例子这里没有做处理）。数据是分页返回的，当还有下一页时，用户可以点击“读取更多”按钮，加载下一页数据拼到当前列表尾部：</p><pre><code class="language-javascript">import React, { useEffect, useState } from 'react';

const BookList = ({ categoryId }) =&gt; {
&nbsp; const [books, setBooks] = useState([]);
&nbsp; const [totalPages, setTotalPages] = useState(1);
&nbsp; const [currentPage, setCurrentPage] = useState(1);
&nbsp; const [isLoading, setIsLoading] = useState(true);
&nbsp; useEffect(() =&gt; {
&nbsp; &nbsp; const fetchBooks = async () =&gt; {
&nbsp; &nbsp; &nbsp; const url = `/api/books?category=${categoryId}&amp;page=${currentPage}`;
&nbsp; &nbsp; &nbsp; const res = await fetch(url);
&nbsp; &nbsp; &nbsp; const { items, totalPages } = await res.json();
&nbsp; &nbsp; &nbsp; setBooks(books =&gt; books.concat(items));
&nbsp; &nbsp; &nbsp; setTotalPages(totalPages);
&nbsp; &nbsp; &nbsp; setIsLoading(false);
&nbsp; &nbsp; };
&nbsp; &nbsp; setIsLoading(true);
&nbsp; &nbsp; fetchBooks();
&nbsp; }, [categoryId, currentPage]);

&nbsp; return (
&nbsp; &nbsp; &lt;div&gt;
&nbsp; &nbsp; &nbsp; &lt;ul&gt;
&nbsp; &nbsp; &nbsp; &nbsp; {books.map((book) =&gt; (
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;li key={book.id}&gt;{book.title}&lt;/li&gt;
&nbsp; &nbsp; &nbsp; &nbsp; ))}
&nbsp; &nbsp; &nbsp; &nbsp; {isLoading &amp;&amp; (&lt;li&gt;Loading...&lt;/li&gt;)}
&nbsp; &nbsp; &nbsp; &lt;/ul&gt;
&nbsp; &nbsp; &nbsp; &lt;button
&nbsp; &nbsp; &nbsp; &nbsp; onClick={() =&gt; setCurrentPage(currentPage + 1)}
&nbsp; &nbsp; &nbsp; &nbsp; disabled={currentPage === totalPages}
&nbsp; &nbsp; &nbsp; &gt;
&nbsp; &nbsp; &nbsp; &nbsp; 读取更多
&nbsp; &nbsp; &nbsp; &lt;/button&gt;
&nbsp; &nbsp; &lt;/div&gt;
&nbsp; );
};

export default BookList;
</code></pre><p>上面的代码中，分页读取书籍列表这部分逻辑，我们可以选择抽取成自定义Hook：<code>useFetchBooks</code>，它的参数只有<code>categoryId</code>，函数体调用了多个基础Hooks，返回值包括<code>books</code>列表、是否读取中<code>isLoading</code>。当前页和总页数做了额外处理，返回计算值<code>hasNextPage</code>和一个回调函数<code>onNextPage</code>。代码如下：</p><pre><code class="language-javascript">import React, { useEffect, useState } from 'react';

function useFetchBooks(categoryId) {
&nbsp; const [books, setBooks] = useState([]);
&nbsp; const [totalPages, setTotalPages] = useState(1);
&nbsp; const [currentPage, setCurrentPage] = useState(1);
&nbsp; const [isLoading, setIsLoading] = useState(true);
&nbsp; useEffect(() =&gt; {
&nbsp; &nbsp; const fetchBooks = async () =&gt; {
&nbsp; &nbsp; &nbsp; const url = `/api/books?category=${categoryId}&amp;page=${currentPage}`;
&nbsp; &nbsp; &nbsp; const res = await fetch(url);
&nbsp; &nbsp; &nbsp; const { items, totalPages } = await res.json();
&nbsp; &nbsp; &nbsp; setBooks(books =&gt; books.concat(items));
&nbsp; &nbsp; &nbsp; setTotalPages(totalPages);
&nbsp; &nbsp; &nbsp; setIsLoading(false);
&nbsp; &nbsp; };
&nbsp; &nbsp; setIsLoading(true);
&nbsp; &nbsp; fetchBooks();
&nbsp; }, [categoryId, currentPage]);
&nbsp; const hasNextPage = currentPage &lt; totalPages;
&nbsp; const onNextPage = () =&gt; {
&nbsp; &nbsp; setCurrentPage(current =&gt; current + 1);
&nbsp; }

&nbsp; return {books, isLoading, hasNextPage, onNextPage};
}

const BookList = ({ categoryId }) =&gt; {
&nbsp; const {
&nbsp; &nbsp; books,
&nbsp; &nbsp; isLoading,
&nbsp; &nbsp; hasNextPage,
&nbsp; &nbsp; onNextPage
&nbsp; } = useFetchBooks(categoryId);

&nbsp; return (
&nbsp; &nbsp; &lt;div&gt;
&nbsp; &nbsp; &nbsp; &lt;ul&gt;
&nbsp; &nbsp; &nbsp; &nbsp; {books.map((book) =&gt; (
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;li key={book.id}&gt;{book.title}&lt;/li&gt;
&nbsp; &nbsp; &nbsp; &nbsp; ))}
&nbsp; &nbsp; &nbsp; &nbsp; {isLoading &amp;&amp; (&lt;li&gt;Loading...&lt;/li&gt;)}
&nbsp; &nbsp; &nbsp; &lt;/ul&gt;
&nbsp; &nbsp; &nbsp; &lt;button onClick={onNextPage} disabled={!hasNextPage}&gt;
&nbsp; &nbsp; &nbsp; &nbsp; 读取更多
&nbsp; &nbsp; &nbsp; &lt;/button&gt;
&nbsp; &nbsp; &lt;/div&gt;
&nbsp; );
};

export default BookList;
</code></pre><p>这个自定义Hook对 <code>BookList</code> 隐藏了与获取书籍列表相关的业务实现。但请注意一点，抽取自定义Hook之前的代码并没有明显的痛点，所以这个抽象并不是必需的，更多还是出于学习目的。</p><p>自定义Hooks也被用于代码复用。</p><p>依然是上面这个例子，假设我们还要开发一个杂志列表组件 <code>MagazineList</code> ，读取远程数据逻辑与书籍列表十分相似，只有REST API的URL不同，那么我们可以对 <code>useFetchBooks</code> 进行一个小改造，把API URL作为可选参数传入 <code>useFetchBooks</code> ：</p><pre><code class="language-javascript">function useFetchBooks(categoryId, apiUrl = '/api/books') {
  const [books, setBooks] = useState([]);
  const [totalPages, setTotalPages] = useState(1);
  const [currentPage, setCurrentPage] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  useEffect(() =&gt; {
    const fetchBooks = async () =&gt; {
      const url = `${apiUrl}?category=${categoryId}&amp;page=${currentPage}`;
      const res = await fetch(url);
      // ...
</code></pre><p>在组件中就可以复用这个Hook了：</p><pre><code class="language-javascript">const MagazineList = ({ categoryId }) =&gt; {
&nbsp; const {
&nbsp; &nbsp; books,
&nbsp; &nbsp; isLoading,
&nbsp; &nbsp; hasNextPage,
&nbsp; &nbsp; onNextPage
&nbsp; } = useFetchBooks(categoryId, '/api/magazines');
  // ...
</code></pre><p>只要遵循Hooks的使用规则，一个组件中可以使用多个自定义Hooks，自定义Hooks里面也可以调用其他自定义Hooks。</p><h2>组件组合</h2><p>与组件抽象对应的概念是<strong>组件扩展（Extension）</strong>，我们先来归纳一下组件扩展，以帮助理解如何在React组件层面做抽象。</p><p>组件扩展需要一定的模式，否则就成了代码堆砌。React组件一般以<strong>组合（Composition）</strong>方式应对大部分扩展需求。请你回忆一下 <code>oh-my-kanban</code> 中 <code>KanbanColumn</code> 组件在“大重构”前后的两个版本：</p><ul>
<li>重构前 <code>KanbanColumn</code> 只包含DOM结构和样式的<em>抽象</em>，为具体子组件留下了一个槽位（Slot），是由 <code>App</code> 负责将多个 <code>KanbanColumn</code> 和 <code>KanbanCard</code> 等组件<em>组合</em>在一起；</li>
<li>重构后改为由 <code>KanbanBoard</code> 负责将多个 <code>KanbanColumn</code> <em>组合</em>在一起， <code>KanbanCard</code> 的组合逻辑被转移到 <code>KanbanColumn</code> 的<em>抽象</em>中，由 <code>KanbanColumn</code> 负责把 <code>KanbanCard</code> <em>组合</em>在一起。</li>
</ul><p>那么就可以得出一个方法论，即我们对组件进行抽象的着陆点就是组件的组合，换句话说，<strong>对组件抽象的产物是可以被用于组合的新组件</strong>。</p><p>这里列举一些在大中型React应用中常见的组件抽象的产物：</p><p><img src="https://static001.geekbang.org/resource/image/1e/80/1ee65b2ac356f281915a7a70bb2de080.png?wh=665x200" alt=""></p><p>由此可见，不论是否强调代码复用，我们已经在使用组合方式开发React应用了。</p><h2>高阶组件</h2><p>组件组合有一种重要的设计模式：<strong>高阶组件（HOC，Higher-Order Component）</strong>。高阶组件可以将一个组件转换成为另一个组件，一般用于代码复用。具有以下特征的函数就是高阶组件：</p><pre><code class="language-javascript">const EnhancedComponent = withSomeFeature(WrappedComponent);
//    -----------------   --------------- ----------------
//          |             ----    |               |
//          |              |      |               |
//          V              V      V               V
//       增强组件       (约定前缀) 高阶组件         原组件
</code></pre><p>或者这样：</p><pre><code class="language-javascript">const EnhancedComponent = withSomeFeature(args)(WrappedComponent);
//    -----------------   --------------- ----  ----------------
//          |                    |         |            |
//          |                    V         V            |
//          |                 高阶函数     参数           |
//          |             ---------------------         |
//          |                       |                   |
//          V                       V                   V
//       增强组件                 高阶组件               原组件
</code></pre><p>为了开发高阶组件，一般可以先把多个组件公共的逻辑或者交互，抽取成为一个父组件，再封装成高阶组件。</p><p>比如下面这个显示“读取中”状态的高阶组件，它要做的事情就是从传入的props中拿到 <code>isLoading</code> 属性，如果为 <code>true</code> 则显示一个炫酷的读取中CSS动画，否则直接展示原组件：</p><pre><code class="language-javascript">function withLoading(WrappedComponent) {
  const ComponentWithLoading = ({ isLoading, ...restProps }) {
    // 炫酷的读取中CSS动画
    return isLoading ? (
      &lt;div className="loading"&gt;读取中&lt;/div&gt;
    ) : (
      &lt;WrappedComponent {...restProps} /&gt;
    );
  };
  return ComponentWithLoading;
}

// ...
const EnhancedMovieList = withLoading(MovieList);
// ...
&lt;MovieList movies={movies} /&gt;
&lt;EnhancedMovieList isLoading={isLoading} movies={movies} /&gt;
</code></pre><p>这个高阶组件不仅可以用于 <code>MovieList</code> ，还可以用于 <code>TvShowList</code> 、 <code>MtvList</code> ，是一个可复用的抽象。</p><p>此外还可以从高阶组件中创建新的props传递给原组件，以下是高阶组件 <code>withRouter</code> 的示意代码，来自React路由框架react-router v6的官方文档：</p><pre><code class="language-javascript">function withRouter(WrappedComponent) {
&nbsp; function ComponentWithRouterProp(props) {
&nbsp; &nbsp; const location = useLocation();
&nbsp; &nbsp; const navigate = useNavigate();
&nbsp; &nbsp; const params = useParams();
&nbsp; &nbsp; return (
&nbsp; &nbsp; &nbsp; &lt;WrappedComponent
&nbsp; &nbsp; &nbsp; &nbsp; {...props}
&nbsp; &nbsp; &nbsp; &nbsp; router={{ location, navigate, params }}
&nbsp; &nbsp; &nbsp; /&gt;
&nbsp; &nbsp; );
&nbsp; }
&nbsp; return ComponentWithRouterProp;
}
</code></pre><p>可以看出，这个 <code>withRouter</code> 就是三个自定义Hooks的组合，创建了一个新的 <code>router</code> 属性传给了原组件，这跟在原组件中直接使用三个Hooks区别不大。其实这个高阶组件主要还是给类组件用的，毕竟类组件无法直接使用Hooks。</p><p>高阶组件也可以组合使用，比如：</p><pre><code class="language-javascript">const EnhancedMovieList = withRouter(withLoading(MovieList));
</code></pre><p>这时推荐使用Redux的 <code>compose</code> 函数来改善代码的可读性：</p><pre><code class="language-javascript">const enhance = compose(
  withRouter,
  withLoading
);
const EnhancedMovieList = enhance(MovieList);
</code></pre><p>以上的例子都相对简单，当必要时，可以在高阶组件内部加入相关的state、Hooks，以封装一段完整的业务或交互逻辑。比如下面这个高阶组件 <code>withLoggedInUserContext</code> ，在用户尚未登录时显示登录对话框，登录成功后从服务器端读取当前用户数据，并把用户数据放到 <code>LoggedInUserContext</code> 中，供后代组件使用：</p><pre><code class="language-javascript">export const LoggedInUserContext = React.createContext();

function withLoggedInUserContext(WrappedComponent) {
&nbsp; const LoggedInUserContainer = (props) =&gt; {
&nbsp; &nbsp; const [isLoggedIn, setIsLoggedIn] = useState(false);
&nbsp; &nbsp; const [isLoading, setIsLoading] = useState(true);
&nbsp; &nbsp; const [currentUserData, setCurrentUserData] = useState(null);
&nbsp; &nbsp; useEffect(() =&gt; {
&nbsp; &nbsp; &nbsp; async function fetchCurrentUserData() {
&nbsp; &nbsp; &nbsp; &nbsp; const res = await fetch('/api/user');
&nbsp; &nbsp; &nbsp; &nbsp; const data = await res.json();
&nbsp; &nbsp; &nbsp; &nbsp; setCurrentUserData(data);
&nbsp; &nbsp; &nbsp; &nbsp; setIsLoading(false);
&nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; if (isLoggedIn) {
&nbsp; &nbsp; &nbsp; &nbsp; setIsLoading(true);
&nbsp; &nbsp; &nbsp; &nbsp; fetchCurrentUserData();
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }, [isLoggedIn]);

&nbsp; &nbsp; return !isLoggedIn ? (
&nbsp; &nbsp; &nbsp; &lt;LoginDialog onLogin={setIsLoggedIn} /&gt;
&nbsp; &nbsp; ) : isLoading ? (
&nbsp; &nbsp; &nbsp; &lt;div&gt;读取中&lt;/div&gt;
&nbsp; &nbsp; ) : (
&nbsp; &nbsp; &nbsp; &lt;LoggedInUserContext.Provider value={currentUserData}&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;WrappedComponent {...props} /&gt;
&nbsp; &nbsp; &nbsp; &lt;/LoggedInUserContext.Provider&gt;
&nbsp; &nbsp; )
&nbsp; }
}
</code></pre><p>这个 <code>withLoggedInUserContext</code> 看似很完整，但也有一些值得推敲的地方，比如：</p><ul>
<li>如果在整个应用中只使用一次这个高阶组件，那么是不是没必要封装成高阶组件？</li>
<li>如果在应用组件树的不同分支中，多次使用这个高阶组件，会不会导致出现多个登录对话框？</li>
<li>考虑单一职责原则（Single Responsibility Principle），这个高阶组件是不是承担了太多职责？</li>
</ul><p>老实说，尤其在React Hooks成为主流以后，我所开发过或者见到过的高阶组件，还是在React组件库或React相关框架里的居多，而在React应用项目中比较少见。对抽象高阶组件，我建议至少满足以下前提之一：</p><ul>
<li>你在开发React组件库或React相关框架；</li>
<li>你需要在类组件中复用Hooks逻辑；</li>
<li>你需要复用包含视图的逻辑。</li>
</ul><h2>小结</h2><p>在这节课，我们了解了在组件逻辑越来越复杂时，即便不考虑代码复用，也可以通过抽象来简化组件的设计和开发，学习了React中的自定义Hooks和组件组合这两种抽象方式。进一步地，也学习了在自定义Hooks和组件组合基础上的代码复用，尤其是组件组合的重要设计模式之一：高阶组件的写法。</p><p>这节课一开始也提到过，组件逻辑属于是React应用的局部逻辑。下节课，我们会继续讨论React应用的整体逻辑，看看大中型React项目在代码增多后，整体扩展上会遇到哪些挑战，以及如何应对这些挑战。</p><h2>思考题</h2><ol>
<li>
<p>这节课自定义Hooks的样例代码<code>useFetchBooks</code> 中，返回值是一个对象，使用这个自定义Hook时，可以用属性解构的方式直接获得其中的属性，然而基础Hooks之一的 <code>useState</code> ，它的返回值却是一个具有两个成员的数组，请你思考一下这两种返回值类型，各有什么好处？</p>
</li>
<li>
<p><a href="https://time.geekbang.org/column/article/577223">第15节课</a>我们讲到了React内建的纯组件API React.memo，可以请你根据它的功能描述，在不参考React源码的前提下，自己实现一个用于纯组件的高阶组件吗？</p>
</li>
</ol><p>好了，这节课的内容就是这些。我们下节课再见。</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/c8/04/fed4c1ad.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>若川</span>
  </div>
  <div class="_2_QraFYR_0">思考题：<br>1. useState 只有两个值的数组，优点：解构命名方便，缺点：要按顺序。<br><br>const [name, setName] = useState()<br><br>自定义 hooks。返回对象，优点：不需要按顺序可以解构。缺点：解构如果需要重命名相对麻烦，比如const {name: PersonName} = useHooks();<br><br>一般来说超过三个用对象形式比较好。<br><br>2. 暂时实现不出~贴下 React.memo 源码链接: https:&#47;&#47;github.com&#47;facebook&#47;react&#47;blob&#47;main&#47;packages&#47;react&#47;src&#47;ReactMemo.js</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，若川，你的第1题答案已经是标准答案了，赞 ：） </p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-16 22:28:54</div>
  </div>
</div>
</div>
</li>
</ul>