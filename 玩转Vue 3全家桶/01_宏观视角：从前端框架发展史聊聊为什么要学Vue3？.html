<audio title="01_宏观视角：从前端框架发展史聊聊为什么要学Vue3？" src="https://static001.geekbang.org/resource/audio/50/01/509824c444085b2b0463c7d38abaa801.mp3" controls="controls"></audio> 
<p>你好，我是大圣。</p><p>今天，我们来聊一聊前端框架的发展历史。在熟悉这段历史之后，相信你能把握到 Vue 在前端框架中的地位。这样，你就会对 Vue 有一个更精准的定位，从而能够知道我们为什么要选择 Vue 框架，以及Vue的优势和它的真正价值在哪里。</p><p>同时，前端框架的发展历史可能也会让你感触很多。因为每一个上网的人，或多或少都会感觉到前端网页在这些年发生了很多的变化，这是一种切身的、直观的体会。我们都能感觉到网页在设计模式、渲染等等地方的变化，而这种种变化的背后，其实都可以放到前端框架的演变历史中来解释。</p><h2>石器时代</h2><p>谈前端框架发展史之前，我们先来简单回顾一下前端的发展历史吧。</p><ul>
<li>1990 年，第一个 Web 浏览器诞生了。这是前端这个技术的起点，代表这一年它出生了。后面的时间里，前端圈有很多里程碑事件。</li>
<li>1994 年，网景公司发布第一个商业浏览器 Navigator。</li>
<li>1995 年，网景工程师 Brendan Eich 用 10 天时间设计了 JavaScript，同年微软发布了 IE 浏览器，进而掀起了浏览器大战。</li>
<li>2002年，IE在浏览器大战中赢得胜利，IE6占有率超过96% 。</li>
</ul><p>而前端的发展历史，又非常直观地显示在你看到的前端网页的演变历史中。整个90年代，受限于网速，网页都是静态页，显示非常单一，前端的工作大部分都只是让美工来切切图和写写HTML+CSS。也因此，在90年代，前端还处在一种萌发期的状态，前端工程师这一工种也没有明确出现。</p><!-- [[[read_end]]] --><p>再后来，后端越来越复杂，开始分层。就像在小公司里，大家啥都干，但公司规模大了之后，就要分部门，职责明确，代码也从揉在一起发展到Model，View和Controller，分别负责不同的功能。</p><p><strong>这就是后端MVC模式的盛行，让我们可以在模板里写上要展现的数据。以前的代码都是所有内容写在一起，现在就会用Model负责数据。</strong></p><p>后端渲染页面之前，会把数据库的数据显示在前端。这个时候，除了写前端代码必备的HTML、CSS和简单的JavaScript动效，我们也开始用到了JSP和Smarty，我们会写出如下这种代码：</p><pre><code class="language-xml">&lt;!DOCTYPE html&gt;
  &lt;html&gt;
  &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;smarty test1&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  它的名字叫{$name}
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre><p>上述代码写出来的页面，就可以直接显示后端数据库里的数据了，这也就是所谓的动态网页。动态页面使得前端本身的丰富程度大大提升。这一下子迎来了整个互联网开发的繁荣时期，但这种模式下的任何数据更新，都需要刷新整个页面，并且在带宽不足的年代，这样做会耗费不少加载网页的时间。</p><p>所以这个时代的网页主要还是以显示数据和简单的特效为主，比如当时众多的门户网站，也都没有太多的用户交互，主要就是显示后端存储的新闻。</p><p>直到2004年，Google发布了Gmail，用户可以在不刷新页面的情况下进行复杂的交互，之后，Ajax逐渐成为网页开发的技术标准，也不断地被应用于各种网站。<strong>Ajax这个技术让我们可以异步的获取数据并且刷新页面，从此前端不再受限于后端的模板，这也宣告了Web2.0时代正式到来。</strong>至此，前端工程师也正式作为一个独立工种出现。</p><h2>铁器时代</h2><p>在Gmail诞生后，虽然依然有浏览器的混战和兼容性问题，比如绑定事件不同的浏览器就要写不同的代码，但大家意识到前端也可以做出复杂应用。而jQuery的出现迅速风靡全球，一个$走天下，学会jQuery就等同于学会了前端，算是前端车同轴的时代。在这之后，前端的具体开发不再被JavaScript的兼容性问题所困扰。</p><p>那个时候 jQuery+Bootstrap一把梭，成为了前端开发领域的主流技术，前端代码内嵌在后端的项目中，写完直接发布，通篇都是如下的代码：</p><pre><code class="language-xml">$('#alert-btn').on('click',function(){
  $('#app .input').val('hi')
})
</code></pre><p>那个时候写代码，就是找到某个元素，进行DOM操作，特别像铁器时代的拼刺刀，随着前端项目规模的逐渐提升，前端也需要规模化的时候，在2009年AngularJS和Node.js的诞生，也宣告前端工业革命的到来。</p><h2>工业时代</h2><p>AngularJS的诞生，引领了前端MVVM模式的潮流；Node.js的诞生，让前端有了入侵后端的能力，也加速了前端工程化的诞生。现在前端三大框架Angular、React、Vue 的发展主线，也就是从这里开始的。</p><p>所谓MVVM，就是在前端的场景下，把Controller变成了View-Model层，作为Model和View的桥梁，Model数据层和View视图层交给View-Model来同步，第二讲我们会通过一个清单应用让你熟悉MVVM开发模式和传统jQuery的开发模式的区别，这里你先留个印象就好。</p><h3>前端三大框架</h3><p>在前端MVVM模式下，不同框架的目标都是一致的，就是利用数据驱动页面，但是怎么处理数据的变化，各个框架走出了不同的路线。</p><p><img src="https://static001.geekbang.org/resource/image/b0/93/b0402b9e1b4cb22877fcffb8b43d0193.jpg?wh=1208x678" alt=""></p><p>这些框架要回答的核心问题就是，数据发生变化后，我们怎么去通知页面更新。各大框架在这个步骤上，各显神通：</p><p>Angular 1就是最老套的脏检查。所谓的脏检查，指的是Angular 1在对数据变化的检查上，遵循每次用户交互时都检查一次数据是否变化，有变化就去更新DOM这一方法。这个方法看似简单粗暴，但算是数据驱动页面早期的实现，所以一经推出，就迅速占领了MVVM市场。</p><p>后面Angular团队自断双臂，完全抛弃Angular 1，搞了一个全新的框架还叫Angular，引入了TypeScript、RxJS等新内容，虽然这些设计很优秀，但是不支持向前兼容，抛弃了老用户。这样做也伤了一大批Angular 1用户的心，包括我。这也是Angular这个优秀的框架现在在国内没有大面积推广的原因。</p><p>而Vue 1的解决方案，就是使用响应式，初始化的时候，Watcher监听了数据的每个属性，这样数据发生变化的时候，我们就能精确地知道数据的哪个key变了，去针对性修改对应的DOM即可，这一过程可以按如下方式解构：</p><p><img src="https://static001.geekbang.org/resource/image/c8/0b/c8f234a40e63dbf86809f6885714b10b.jpg?wh=2540x1441" alt=""></p><p>在上图中，左边是实际的网页内容，我们在网页中使用{{}}渲染一个变量，Vue 1就会在内容里保存一个监听器监控这个变量，我们称之为Watcher，数据有变化，watcher会收到通知去更新网页。</p><p>通俗来说，如果把网页数据看成你管理的员工，普通数据就是那种每次你都需要找到他，告诉他要怎么做的人，响应式数据就是他本身有任何变化，都会主动给你发日报告诉你的积极员工。</p><p>此外，Facebook的React团队提出了不同于上面的Angular、Vue的的解决方案，他们设计了React框架，在页面初始化的时候，在浏览器DOM之上，搞了一个叫虚拟DOM的东西，也就是用一个JavaScript对象来描述整个DOM树。我们可以很方便的通过虚拟DOM计算出变化的数据，去进行精确的修改。</p><p>我们先看React中的一段代码：</p><pre><code class="language-xml">&lt;div id = "app"&gt;
    &lt;p class = "item"&gt;Item1&lt;/p&gt;
    &lt;div class = "item"&gt;Item2&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>在React中，这样一段HTML会被映射成一个JavaScript的对象进行描述。这个对象就像数据和实际DOM的一个缓存层，通过管理这个对象的变化，来减少对实际DOM的操作。</p><p>这种形式不仅让性能有个很好的保障，我们还多了一个用JSON来描述网页的工具，并且让虚拟DOM这个技术脱离了Web的限制。因为积累了这么多优势，虚拟DOM在小程序，客户端等跨端领域大放异彩。</p><p>虚拟DOM在运行的时候就是这么一个对象：</p><pre><code class="language-xml">{
  tag: "div",
  attrs: {
    id: "app"
  },
  children: [
    {
      tag: "p",
      attrs: { className: "item" },
      children: ["Item1"]
    },
    {
      tag: "div",
      attrs: { className: "item" },
      children: ["Item2"]
    }
  ]
}
</code></pre><p>这个对象完整地描述了DOM的树形结构，这样数据有变化的时候，我们生成一份新的虚拟DOM数据，然后再对之前的虚拟DOM进行计算，算出需要修改的DOM，再去页面进行操作。</p><p>浏览器操作DOM一直都是性能杀手，而虚拟DOM的Diff的逻辑，又能够确保尽可能少的操作DOM，这也是虚拟DOM驱动的框架性能一直比较优秀的原因之一。</p><p><img src="https://static001.geekbang.org/resource/image/b2/b4/b262c52d5c353008715003fa263403b4.jpg?wh=1970x1445" alt=""></p><h3>Vue 与 React 框架的对比</h3><p>通过上面对前端三大框架的介绍，我们不难发现 Vue 和 React 在数据发生变化后，在通知页面更新的方式上有明显的不同，通俗的来说，就是：<strong>在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而React的数据变化后，我们只能通过新老数据的计算 Diff来得知数据的变化</strong>。</p><p>这两个解决方案都解决了数据变化后，如何通知页面更新的问题，并且迅速地获得了很高的占有率，但是他们都碰到了性能的瓶颈：</p><ul>
<li>对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建Watcher监听，本身就比较损耗性能，项目大了之后每个数据都有一个watcher会影响性能。</li>
<li>对于React的虚拟DOM的Diff计算逻辑来说，如果虚拟DOM树过于庞大，使得计算时间大于16.6ms，那么就可能会造成性能的卡顿。</li>
</ul><p>为了解决这种性能瓶颈， Vue 和 React 走了不同的道路。</p><p>React为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了Fiber架构。通俗来说，就是把整个虚拟DOM树微观化，变成链表，然后我们利用浏览器的空闲时间计算Diff。一旦浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲。</p><p>这种架构虽然没有减少运算量，但是巧妙地利用空闲实现计算，解决了卡顿的问题。你可以看一下我画的图解：</p><p><img src="https://static001.geekbang.org/resource/image/27/23/27dbe22e81ccc1cec8b35b4ee0a06f23.jpg?wh=2796x1564" alt=""></p><p>在上图中，左侧是一个树形结构，树形结构的Diff很难中断；右侧是把树形结构改造成了链表，遍历严格地按照子元素-&gt;兄弟元素-&gt;父元素的逻辑，随时可以中断和恢复Diff 的计算过程。</p><p>为了方便你对计算Diff的理解，我们来看下面这张图：</p><p><img src="https://static001.geekbang.org/resource/image/22/6f/22b7606230e2920584387249a83db36f.jpg?wh=2358x806" alt=""></p><p>这个图里两个虚线之间是浏览器的一帧，高性能的动画要求是60fps，也就是1秒要渲染60次，每一帧的时间就是16.6毫秒，在这16.6毫秒里，浏览器自己的渲染更新任务执行后，会有一部分的空闲时间，这段时间我们就用来计算Diff。</p><p>等到下一帧任务来了，我们就把控制权还给浏览器，让它继续去更新和渲染，等待空闲时间再继续计算，这样就不会导致卡顿。</p><p>Vue 1 的问题在于响应式数据过多，这样会带来内存占用过多的问题。所以 Vue 2 大胆引入虚拟DOM来解决响应式数据过多的问题。</p><p>这个解决方案使用虚拟DOM解决了响应式数据过多的内存占用问题，又良好地规避了React中虚拟DOM的问题， 还通过虚拟DOM给 Vue 带来了跨端的能力。看到这个解决方案的时候，我真是一拍大腿，直呼“真牛！”。</p><p><strong>响应式数据是主动推送变化，虚拟DOM是被动计算数据的Diff，一个推一个拉，它们看起来是两个方向的技术，但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。</strong></p><p>对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟DOM去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟DOM的量级，也控制在了组件的大小。</p><p>这个方案也体现了 Vue 一直以来坚持的中庸的设计思想。</p><p>下图左边就是一个个的组件，组件内部是没有Watcher监听器的，而是通过虚拟DOM来更新，每个组件对应一个监听器，大大减小了监听器的数量。</p><p><img src="https://static001.geekbang.org/resource/image/22/51/2237975345b4cf039a6cd733cd5be451.jpg?wh=7731x6528" alt=""></p><p>除了响应式和虚拟DOM这个维度，Vue和React还有一些理念和路线的不同，在模板的书写上，也走出了template和JSX两个路线。</p><p><img src="https://static001.geekbang.org/resource/image/66/0f/669188c294d8e306072ef4273ec2630f.png?wh=1920x635" alt="图片"></p><p>React的世界里只有JSX，最终JSX都会在Compiler那一层，也就是工程化那里编译成JS来执行，所以React最终拥有了全部JS的动态性，这也导致了React 的API一直很少，只有state、hooks、Component几个概念，主要都是JavaScript本身的语法和特性。</p><p>而 Vue 的世界默认是template，也就是语法是限定死的，比如v-if 和 v-for等语法。有了这些写法的规矩后，我们可以在上线前做很多优化。Vue 3 很优秀的一个点，就是在虚拟DOM的静态标记上做到了极致，让静态的部分越过虚拟DOM的计算，真正做到了按需更新，很好的提高了性能。</p><p><img src="https://static001.geekbang.org/resource/image/64/f9/64e0e2fd877f2d54f4dd97e3dc0b1bf9.png?wh=1334x456" alt=""></p><p>在模板的书写上，除了 Vue 和 React 走出的template和JSX两个路线，还出现了 Svelte 这种框架，没有虚拟DOM的库，直接把模板编译成原生DOM，几乎没有Runtime，所有的逻辑都在Compiler层优化，算是另外一个极致。</p><p><img src="https://static001.geekbang.org/resource/image/ba/b9/bae38yye39eyy1609260caf90271cbb9.png?wh=1920x759" alt="图片"></p><h2>总结</h2><p>了解了前端MVVM框架发展的历史和方向后，相信你脑海里已经建立起了一个前端框架发展的地图，每个框架都在探索自己的路线。后面还会涌现出更多优秀的框架，我们到时候只需要把那个框架纳入到这个地图中去理解，这样你很快就明白这个框架做了什么，而这也是很多前端大神能够快速学习一个新框架的主要原因。</p><p>浏览器的诞生让我们可以方便地显示文本和图片的内容和样式；JavaScript的出现让网页动了起来；Gmail的发布，宣告前端也可以使用Ajax异步加载技术，来进行复杂网页的开发，前端工程师这个工种也正式出现了。</p><p>随着浏览器厂商的混战，各个浏览器都有自己的特色，jQuery框架的出现统一了写法，解决了那个时代最棘手的前端问题：兼容性，极大提高了开发者的效率。</p><p>随着Angular 1的诞生，我们多了一套开发模式，就是数据驱动页面。我们甚至不再需要使用jQuery去寻找DOM，而是只关注数据的来源和修改，这也就是现在我们所处的前端时代。我们所熟悉的Vue、React、Angular和Svelte等框架，都是在数据驱动页面这个场景下涌现的框架。</p><p>相信到这里，你已经大概明白前端的这些框架的风格和特点，以及 Vue 在这些框架中的地位，Vue 3 在Vue 2 的基础之上做了全面的升级，在性能、扩展性和包的大小上，Vue3都有质的飞跃。</p><p>我已经迫不及待地想聊聊 Vue 3 到底有哪些新特性，并且强烈推荐你来学习。</p><h2>思考题</h2><p>在你看来，Vue需不需要React的Fiber呢？</p><p>欢迎在留言区分享你的思考，畅所欲言。如果你觉得今天的内容有所帮助，也欢迎你分享给你身边的朋友，邀请他一起学习。</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>徐洲更</span>
  </div>
  <div class="_2_QraFYR_0">光这一篇就觉得值回票价了！ 之前都不知道怎么入手前端，看完这段历史才知道了学习方向。 迫不及待后面的内容了</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 感谢夸奖，坚持学完肯定更有收获 嘿嘿</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-19 00:14:31</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/2a/fa/02/8e49a29a.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>洛一</span>
  </div>
  <div class="_2_QraFYR_0">怎么加群</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">编辑回复: 你好，加群的链接在课程详情页中有哦，戳链接加入交流群吧</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-19 13:14:06</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/17/52/0e/c5ff46d2.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>CondorHero</span>
  </div>
  <div class="_2_QraFYR_0">Vue 不需要 React 的 Fiber，因为更新系统中的 Watcher 控制在组件级。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，回答正确，不过原因并不是Watcher的级别，而是虚拟Dom控制在组件级，最早Vue3的提案其实是包含时间切片方案的，最后废弃的主要原因，是时间切片解决的的问题，Vue3基本碰不到<br>1. Vue3把虚拟Dom控制在组件级别，组件之间使用响应式，这就让Vue3的虚拟Dom不会过于庞大<br>2. Vue3虚拟Dom的静态标记和自动缓存功能，让静态的节点和属性可以直接绕过Diff逻辑，也大大减少了虚拟Dom的Diff事件<br>3. 时间切片也会带来额外的系统复杂性<br><br>所以引入时间切片对于Vue3来说投入产出比不太理想，在后来的讨论中，Vue3的时间切片方案就被废弃了<br><br>希望能帮到你</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-18 18:01:24</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/2a/fb/0b/6362a743.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>杨村长</span>
  </div>
  <div class="_2_QraFYR_0">我来回答思考题:<br>vue的diff被限制在组件级，这样每次变化影响的只是一颗子树，相对范围较小。所以fiber带来的收益似乎也会降低，fiber要改架构还可能破坏目前稳定的表现。因此不需要。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 村长威武</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-19 14:02:41</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/21/10/5e/42f4faf7.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>天择</span>
  </div>
  <div class="_2_QraFYR_0">请问老师，react的fiber是如何实现的，有浏览器接口吗？怎么知道渲染线程在空闲呢？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 浏览器提供了一个api叫requestIdleCallback, 会在空闲的时候通知你，https:&#47;&#47;developer.mozilla.org&#47;zh-CN&#47;docs&#47;Web&#47;API&#47;Window&#47;requestIdleCallback<br>由于这个api兼容性问题，React自己实现了一个</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-18 18:57:57</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrm1J6MVvFibtUorUn88kfpIVQKI615tzicJZiceBbW4WjiaETzqjtGFTK49EL5lqWPqIDibjCyuEMgzQ/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>xzq</span>
  </div>
  <div class="_2_QraFYR_0">看了之后有两个点我和大圣老师的观点有点不一样：<br>1. 引入虚拟dom的核心并不是为了通过diff得出需要更新的节点从而加快速度(有时候甚至会变慢)。而是给各种类型节点提供了一层向上的抽象， 这种抽象扩展了框架能够完成的功能，和简化了一些操作。在大多数情况下，操作最快的永远是直接操作Dom，这个svelte 好像就是这么做的。<br>2. Vue2.x 中并不是仅仅只有组件级别的watcher ， 每个组件中的响应式数据也有watcher，在对应的deps上。只不过组件内部数据的watcher一般只会通知到组件级别的watcher, 然后由组件级别的watcher通知外部做对应的操作。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 很赞的分享<br>1. 其实让diff更快和支持跨端这两个都算是虚拟Dom diff带来的有点，到底哪个才是核心的也没必要区分， 而且虚拟Dom精确的来说并不是更快，而是复杂度上去之后性能不崩盘，svelte项目大了之后其实代码体积会变得比较大<br>2。我想表达的就是只有一个渲染Watcher，如果组件内部配置了watch啥的其实也都会有</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-26 23:24:55</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/15/8fcf8038.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>William</span>
  </div>
  <div class="_2_QraFYR_0">树形结构的diff很难中断，请问有什么依据吗？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 树形结构的Diff用的是递归，递归本身就不太好中断 ，你可以脑补一下 如果两棵树做对比，再一个节点停下来了，你需要记录的是层级，别的节点的状态等</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-18 23:41:57</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/UIImmYqAmhyFp1scKEKnCJwfaLnhObQiaYOX1hVlR0RGgH6Psx4ue3R5Cib8naxZSAehk1DMUbWz8afzAKMibGHfA/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Geek_3beb80</span>
  </div>
  <div class="_2_QraFYR_0">由于vue只在组件级别diff，单个组件过于庞大会影响diff效率，过小会增加wacher的数量，改如何取舍呢</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你在设计组件的时候主要考虑功能即可，Vue有点像自动挡，很多优化都帮你做了， 尽量不要拆的太碎，因为虚拟Dom 是做了很多静态优化的，只要按照功能模块拆即可</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-21 12:16:46</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erDeOuPaaRAgWLLIdarW4RI2xrgdDkaPVLNuyba5kVFtCrqOialpOjkCgqZyOfxfxXJKd8a6jDI98g/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Mserke</span>
  </div>
  <div class="_2_QraFYR_0">请问 Vue 2 引入虚拟 DOM 给 Vue 带来了跨端的能力，这句话怎么理解呢？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 虚拟Dom带来的能力，就是我们可以使用JSON描述Vue项目，我们可以基于这个JSON，在小程序渲染，在app上渲染，这是Vue1没有的能力</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-23 15:59:19</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/1c/ed/48/4a40816a.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>刷子iNG</span>
  </div>
  <div class="_2_QraFYR_0">感觉懂了，但是细想来还是不懂，给自己占坑，希望学完后能解决自己的疑问：<br>1.vue1 的 watcher 指的是 Object.defineProperty 吗？数据变化之后在 setter 里面去更新对应的dom？<br><br>2.当数据变更后，是怎么通知react更新虚拟 dom 的呢？不需要 watcher 吗？<br><br>3.为什么vue2引入了虚拟dom就能解决响应式数据过的内存问题呢？vue 中的data不都是响应式的吗？当dom过多 虚拟dom就没有性能问题吗？<br><br>4.什么叫组件的变化通过响应式的更新，内部数据的变化通过虚拟dom去更新，不都是数据驱动视图更新，两者的差异是怎么实现的呢？ watcher 是什么？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 1. 可以这个理解，不过setter也有一些优化策略<br>2. react不是直接修改数据，而是使用setState这种函数去操作，可以在函数内部去完成通知<br>3. 引入虚拟Dom后，一个组件一个Watcher，组件内部虚拟Dom，组件的量级不会大到diff时间超过16。6ms<br>5. 组件之间的数据更新，是通过响应式去通知，组件内部没有响应式的wathcer，而是通过虚拟Dom更新</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-22 00:25:27</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/22/73/ff/3e30f1c6.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>嘿吼</span>
  </div>
  <div class="_2_QraFYR_0">宝！好好休息，千万别累到自己！吃完饭就抓紧去写稿子吧</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 知道了大兄弟，垫吧两口就去了</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-19 17:39:26</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/1e/be/30/0a85890d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>🐬🐳🐟🐟🐳🐟🐳🐟🐟</span>
  </div>
  <div class="_2_QraFYR_0">fiber出现 的本意是减小虚拟dom diff的成本，理论上来说，vue 将 dom diff 压缩到了组件级别，应该不需要 fiber，同时 fiber 也会带来一些 性能损耗。 但也可能存在单个组件比较庞大的情况，不过本着组件化的思想，开发人员应该也会对其进行合理拆分，所以我觉得基本fiber 大概率不会在 vue3 中出现。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 正解！</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-23 10:43:20</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/b5/32/43b46132.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>褚琛</span>
  </div>
  <div class="_2_QraFYR_0">老师您好，我想问一下虚拟DOM树转换成链表结构，树结构是怎么转换成链表结构的呢？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 从代码角度来说，就是修改的指向，比如之前的节点代码是<br>let vnode = {name:&quot;div&quot;, children:[vnode1,vnode2]}<br>用children来管理子元素，children中的vnode继续嵌套<br>现在的代码就是<br>let vnode = {name:&quot;div&quot;, child:vnode1, slibling:vnode4, parent:vnode5}<br>就变成了单个的指向</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-22 11:47:39</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/1d/8a/d7/daabec34.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>tequ1lAneio</span>
  </div>
  <div class="_2_QraFYR_0">vue真正需要fiber的情况会非常极端，除非有超大面积的组件在同一时间需要同时进行更新。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 确实是因为这个才废弃了这个提案</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-20 22:07:46</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq6UjL0SBicZgyKzsAnCf08l0MibyqxsCecSVXa3tKvSDeDG6XRe1ngziaChRiaRcA0kzOlIwfcnNZvwg/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Alias</span>
  </div>
  <div class="_2_QraFYR_0">react和vue的主要区别：<br>1 数据更新上：react 采用fiber架构，使用链表表示DOM结构可以在diff时随时中断和继续，利用requestIdleCallback在空闲时diff，防止数据量大diff时间长导致卡顿；vue采用响应式，一个组件对应一个观察者对象，数据变更触发dom diff，将dom diff控制在组件级别； <br>2 模板不同：一个jsx 一个template</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 第一部分说的不错，第二条的话，其实Vue也有jsx的</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-19 15:53:49</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/ec/68/06d59613.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>柒月</span>
  </div>
  <div class="_2_QraFYR_0">vue2转react，还是放不下vue3啊  哈哈哈</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 看来还是心头爱呀 哈哈哈</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-21 15:00:12</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/3f/a8/8da58e53.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>海阔天空</span>
  </div>
  <div class="_2_QraFYR_0">感觉vue不需要React的Fiber。每个vue组件都有自己的watcher，可以监听每个组件整体的变化。当然，如果有些组件比较大，或是数据比较多时，是会出现卡顿现象。所以我们在编码时，尽量优化好我们的组件。避免单个组建过大，过于复杂。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 很赞，除了这个之外，Vue3的虚拟Dom还做了静态标记，静态的节点和属性会越过Diff逻辑，所以基本上碰不到会Diff卡顿的情况</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-20 21:18:08</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/15/8fcf8038.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>William</span>
  </div>
  <div class="_2_QraFYR_0">我认为虚拟dom并没有脱离web的限制，react native和小程序还是基于web技术</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 用一个对象去描述页面，其实就是脱离了Web，React native算是首先跨端的尝试， 还有很多有意思的项目，还有把虚拟Dom渲染成命令行应用的<br>只不过现在生态语言用的还是Node，以后肯定会越来越多</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-18 23:38:42</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/28/7c/ce/d8a960f4.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>😉</span>
  </div>
  <div class="_2_QraFYR_0">刚学了vue，做了个ant-design-vue的小作品，刚好能再精进一下学vue全家桶</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，能实现这个antd-vue的作品就很棒了呀，可以把github地址分享出来 一起交流 感谢支持呀</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-18 20:44:43</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>宋承亮</span>
  </div>
  <div class="_2_QraFYR_0">大圣老师，yyds，从B站来的</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你好，原来是老朋友 欢迎欢迎呀</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-18 20:29:50</div>
  </div>
</div>
</div>
</li>
</ul>